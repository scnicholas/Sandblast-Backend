<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nyx Avatar Host</title>

  <!-- Use the real skin -->
  <link rel="stylesheet" href="./avatar.css" />

  <!-- Host-only tiny layout helpers (kept minimal; aesthetics live in avatar.css) -->
  <style>
    body{margin:0}
    #wrap{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      padding:12px;
      height:100vh;
      box-sizing:border-box;
    }
    #avatarRoot{
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      overflow:hidden;
      min-height:420px;
      position:relative;
      background: rgba(12,12,18,.55);
    }
    #panel{
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:12px;
      background: rgba(18,18,26,.55);
      backdrop-filter: blur(8px);
    }
    .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
    textarea{
      width:100%;
      box-sizing:border-box;
      background:#0f0f16;
      color:#fff;
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      padding:10px;
    }
    .hud{font:12px ui-monospace,Menlo,Consolas,monospace;opacity:.9;line-height:1.5}
    .hud b{opacity:.85}
    button{
      background:#141421;
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:8px 10px;
      cursor:pointer;
    }
    button:hover{ border-color: rgba(255,255,255,.22); }

    /* Overlay layer inside avatarRoot */
    .overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:20;
    }
    .overlay-inner{
      position:absolute;
      left:0; right:0;
      bottom:14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      padding:0 12px;
      pointer-events:none;
    }
    .overlay-inner .bubble,
    .overlay-inner .chip,
    .overlay-inner .action-pill{
      pointer-events:auto;
    }
    .is-hidden{ display:none !important; }

    /* Ensure the avatar stage is centered nicely */
    #nyxShellMount{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:10;
    }

    /* Embedded mode: hide debug panel + tighten grid */
    .embed #wrap{
      grid-template-columns: 1fr;
      padding:0;
      height:100vh;
    }
    .embed #panel{ display:none; }
    .embed #avatarRoot{
      border-radius:0;
      border:0;
      height:100vh;
      min-height:100vh;
    }
  </style>
</head>

<body>
  <div id="wrap">

    <!-- LEFT: Avatar stage -->
    <div id="avatarRoot">

      <!-- Guaranteed mount target + fallback avatar DOM.
           Shell can enhance/replace this; but even if shell fails, you SEE Nyx. -->
      <div id="nyxShellMount">
        <div class="avatar gaze-soft mood-attentive" id="nyxAvatar">
          <div class="silhouette">
            <div class="head">
              <div class="eye left">
                <div class="pupil"></div>
                <div class="lid"></div>
              </div>
              <div class="eye right">
                <div class="pupil"></div>
                <div class="lid"></div>
              </div>
              <div class="mouth"></div>
            </div>
            <div class="shoulders"></div>
          </div>
        </div>
      </div>

      <!-- Overlay UI (bubble + chips) -->
      <div class="overlay" id="nyxOverlay">
        <div class="overlay-inner">

          <div class="bubble" id="nyxBubble">
            <div class="bubble-text" id="nyxBubbleText">
              Hi… I’m Nyx. How are you today?
            </div>

            <div class="bubble-actions" id="nyxBubbleActions">
              <div class="action-pill general" data-chip="general">General</div>
              <div class="action-pill" data-chip="music">Music</div>
              <div class="action-pill" data-chip="roku">Roku</div>
              <div class="action-pill schedule" data-chip="schedule">Schedule<span class="ext">↗</span></div>
              <div class="action-pill" data-chip="radio">Radio</div>
            </div>
          </div>

          <div class="chips" id="nyxChips">
            <div class="chip is-active" data-chip="general">General</div>
            <div class="chip" data-chip="music">Music</div>
            <div class="chip" data-chip="roku">Roku</div>
            <div class="chip" data-chip="schedule">Schedule<span class="ext">↗</span></div>
            <div class="chip" data-chip="radio">Radio</div>
          </div>

        </div>
      </div>
    </div>

    <!-- RIGHT: Debug + manual controls (auto-hidden when embedded) -->
    <div id="panel">
      <div class="row">
        <button data-act="armAudio">Arm Audio</button>
        <button data-act="idle">Idle</button>
        <button data-act="listen">Listen</button>
        <button data-act="speak">Speak</button>
        <button data-act="toggleVelvet">Velvet</button>
      </div>

      <textarea id="prompt" rows="4" placeholder="Type a message…"></textarea>
      <div class="row">
        <button data-act="sendChat">Send /api/chat</button>
        <button data-act="speakText">Speak /api/tts</button>
      </div>

      <div class="hud">
        <div><b>presence</b>: <span id="hudPresence">idle</span></div>
        <div><b>stage</b>: <span id="hudStage">warm</span></div>
        <div><b>dominance</b>: <span id="hudDom">neutral</span></div>
        <div><b>velvet</b>: <span id="hudVelvet">0</span></div>
        <div><b>anim</b>: <span id="hudAnim"></span></div>
        <div><b>amp</b>: <span id="hudAmp">0.00</span></div>
        <div style="margin-top:10px;opacity:.9">
          <b>bridge</b>: <span id="hudBridge">waiting</span><br/>
          <b>parent</b>: <span id="hudParent">—</span><br/>
          <b>apiBase</b>: <span id="hudApi">—</span><br/>
          <b>token</b>: <span id="hudToken">—</span><br/>
          <b>tokenHeader</b>: <span id="hudTokenHeader">—</span>
        </div>
      </div>

      <audio id="nyxAudio" preload="auto" style="display:none"></audio>
    </div>

  </div>

  <!-- IMPORTANT: keep these relative so /avatar/avatar-host.html serves them correctly -->
  <script src="./avatar-contract.js"></script>
  <script src="./nyx-avatar-shell.js"></script>
  <script src="./avatar-controller.js"></script>
  <script src="./avatar-bridge.js"></script>

  <script>
    (function(){
      // ============================
      // Avatar Host Hardening
      // - Parent origin allowlist enforcement
      // - Lock parent origin on first valid NYX_CONFIG
      // - TokenHeader support (X-SB-WIDGET-TOKEN default)
      // - Token-injecting fetch wrapper for /api/*
      // - No raw token leakage in ACK
      // ============================

      // ----------------------------
      // Embedded mode detection
      // ----------------------------
      var EMBEDDED = false;
      try{ EMBEDDED = (window.top !== window.self); }
      catch(_){ EMBEDDED = true; } // cross-origin throws: assume embedded
      if (EMBEDDED) document.documentElement.classList.add('embed');

      // ----------------------------
      // Host UI handles (kept)
      // ----------------------------
      window.NYX_HOST_UI = {
        root: document.getElementById('avatarRoot'),
        overlay: document.getElementById('nyxOverlay'),
        bubble: document.getElementById('nyxBubble'),
        bubbleText: document.getElementById('nyxBubbleText'),
        bubbleActions: document.getElementById('nyxBubbleActions'),
        chips: document.getElementById('nyxChips')
      };

      // ----------------------------
      // Utils
      // ----------------------------
      function safeStr(x){ return (x===null||x===undefined) ? "" : String(x); }
      function isObj(x){ return !!x && typeof x === "object" && !Array.isArray(x); }

      function setHud(id, val){
        var el = document.getElementById(id);
        if(el) el.textContent = safeStr(val || "—");
      }

      function isTokenOk(t){
        t = safeStr(t).trim();
        return t.length >= 12;
      }

      function normalizeApiBase(s){
        s = safeStr(s).trim().replace(/\/+$/,"");
        return s;
      }

      function normalizeHeroSrc(src){
        src = safeStr(src).trim();
        if(!src) return "";
        if (/^file:\/\//i.test(src)) return "";
        if (/^https?:\/\//i.test(src)) return src;
        if (src[0] !== "/") src = "/" + src;
        return src;
      }

      function preloadImage(src){
        src = normalizeHeroSrc(src);
        if(!src) return;
        try{
          var img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.src = src;
        }catch(_){}
      }

      // ----------------------------
      // Shell mount wiring (heroSrc)
      // ----------------------------
      function mountShellFromConfig(){
        try{
          var mountEl = document.getElementById("nyxShellMount");
          if(!mountEl) return;

          var hero = (window.NYX_CONFIG && window.NYX_CONFIG.heroSrc) ? normalizeHeroSrc(window.NYX_CONFIG.heroSrc) : "";
          if (hero) preloadImage(hero);

          if (window.NyxAvatarShell && typeof window.NyxAvatarShell.getInstance === "function") {
            var inst = window.NyxAvatarShell.getInstance();
            if (inst && inst.el && inst.el.parentNode) {
              try{
                if (hero && typeof inst.setHero === "function") inst.setHero(hero);
                if (hero && typeof inst.setHeroSrc === "function") inst.setHeroSrc(hero);
                if (hero && typeof inst.applyDirective === "function") inst.applyDirective({ heroSrc: hero });
              }catch(_){}
              return;
            }
          }

          if(!window.NyxAvatarShell || typeof window.NyxAvatarShell.mount !== "function") return;
          window.NyxAvatarShell.mount(mountEl, { heroSrc: hero || "" });
        }catch(_){}
      }

      window.addEventListener("nyx:config", function(){ mountShellFromConfig(); });
      document.addEventListener("DOMContentLoaded", function(){
        setTimeout(mountShellFromConfig, 50);
        setTimeout(mountShellFromConfig, 450);
      });

      // ----------------------------
      // Bridge config + security
      // ----------------------------
      var CFG = {
        token: "",
        enforce: true,
        apiBase: "",
        allowedOrigins: [],
        urls: {},
        heroSrc: "",
        tokenHeader: "X-SB-WIDGET-TOKEN"
      };

      // Once set, only accept future messages from this origin
      var LOCKED_PARENT_ORIGIN = "";

      function parseTokenHeader(p){
        var h = safeStr(p.tokenHeader || p.token_header || p.tokenHeaderName || "").trim();
        // Very small sanitation: forbid whitespace/control
        if(!h) h = "X-SB-WIDGET-TOKEN";
        if (/[\s\r\n\t]/.test(h)) h = "X-SB-WIDGET-TOKEN";
        return h;
      }

      function originInAllowlist(origin, list){
        if(!origin || origin === "null") return false;
        if(!Array.isArray(list) || !list.length) return false;
        for (var i=0;i<list.length;i++){
          if (safeStr(list[i]) === origin) return true;
        }
        return false;
      }

      function originAllowed(incomingOrigin, incomingAllowlist){
        // If we already locked the parent, only accept from that parent.
        if (LOCKED_PARENT_ORIGIN) return incomingOrigin === LOCKED_PARENT_ORIGIN;

        // During initial handshake, require the parent to be in the provided allowlist (embedded mode only).
        if (EMBEDDED){
          return originInAllowlist(incomingOrigin, incomingAllowlist);
        }

        // Standalone mode: accept local messages but don't lock.
        return !!incomingOrigin && incomingOrigin !== "null";
      }

      function exposeConfig(){
        window.NYX_CONFIG = {
          token: CFG.token,
          enforce: CFG.enforce,
          apiBase: CFG.apiBase,
          allowedOrigins: (CFG.allowedOrigins || []).slice(0),
          urls: Object.assign({}, CFG.urls || {}),
          heroSrc: CFG.heroSrc || "",
          tokenHeader: CFG.tokenHeader || "X-SB-WIDGET-TOKEN"
        };

        window.NYX_API_BASE = CFG.apiBase;
        window.NYX_TOKEN = CFG.token;

        window.dispatchEvent(new CustomEvent("nyx:config", { detail: window.NYX_CONFIG }));
      }

      // ----------------------------
      // Token-injecting fetch wrapper
      // ----------------------------
      var _nativeFetch = window.fetch ? window.fetch.bind(window) : null;

      function resolveUrl(input){
        try{
          if (typeof input === "string") return input;
          if (input && typeof input === "object" && input.url) return String(input.url);
        }catch(_){}
        return "";
      }

      function isApiRequest(urlStr){
        urlStr = safeStr(urlStr);

        // Relative /api/*
        if (/^\/api\//i.test(urlStr)) return true;

        // Absolute /api/*
        try{
          var abs = new URL(urlStr, window.location.href);
          if (!/^\/api\//i.test(abs.pathname)) {
            // Allow exact "<apiBase>/api/*" too
            if (CFG.apiBase){
              try{
                var b = new URL(CFG.apiBase, window.location.href);
                if (abs.origin === b.origin && abs.pathname.indexOf("/api/") === 0) return true;
              }catch(_){}
            }
            return false;
          }

          // If absolute /api/*: accept if it's same-origin, or matches apiBase origin if set
          if (CFG.apiBase){
            try{
              var base = new URL(CFG.apiBase, window.location.href);
              return (abs.origin === base.origin);
            }catch(_){
              return (abs.origin === window.location.origin);
            }
          }
          return (abs.origin === window.location.origin);
        }catch(_){}
        return false;
      }

      function injectTokenHeaders(init){
        init = init || {};
        var headers = init.headers;

        var out = {};
        try{
          if (headers && typeof Headers !== "undefined" && headers instanceof Headers){
            headers.forEach(function(v,k){ out[k] = v; });
          } else if (Array.isArray(headers)){
            headers.forEach(function(pair){
              if (Array.isArray(pair) && pair.length >= 2) out[String(pair[0])] = String(pair[1]);
            });
          } else if (headers && typeof headers === "object"){
            Object.keys(headers).forEach(function(k){ out[k] = headers[k]; });
          }
        }catch(_){}

        var key = CFG.tokenHeader || "X-SB-WIDGET-TOKEN";
        var token = CFG.token;

        if (token){
          var has = false;
          Object.keys(out).forEach(function(k){
            if (String(k).toLowerCase() === String(key).toLowerCase()) has = true;
          });
          if (!has) out[key] = token;
        }

        // Only set Content-Type if caller didn't provide one.
        var hasCT = false;
        Object.keys(out).forEach(function(k){
          if (String(k).toLowerCase() === "content-type") hasCT = true;
        });
        if (!hasCT) out["Content-Type"] = "application/json";

        init.headers = out;
        return init;
      }

      function nyxFetch(input, init){
        if (!_nativeFetch) throw new Error("fetch_not_supported");
        var url = resolveUrl(input);
        if (isApiRequest(url)) init = injectTokenHeaders(init);
        return _nativeFetch(input, init);
      }

      // Expose helpers for other scripts (preferred)
      window.NYX_FETCH = nyxFetch;
      window.NYX_TOKEN_HEADER = function(){ return CFG.tokenHeader || "X-SB-WIDGET-TOKEN"; };

      // Compatibility: monkey-patch fetch to auto-inject on /api/*
      if (_nativeFetch){
        window.fetch = function(input, init){
          try{
            var url = resolveUrl(input);
            if (isApiRequest(url)) return nyxFetch(input, init);
          }catch(_){}
          return _nativeFetch(input, init);
        };
      }

      // ----------------------------
      // Config apply
      // ----------------------------
      function applyConfig(payload, senderOrigin){
        var p = isObj(payload) ? payload : {};
        var incomingAllow = Array.isArray(p.allowedOrigins) ? p.allowedOrigins.map(String) : [];

        // HARD GATE (embedded): sender must be in allowlist BEFORE any lock/config
        if (EMBEDDED){
          if (!originAllowed(senderOrigin, incomingAllow)) return false;
        } else {
          // Standalone: accept, but don't lock
          if (!senderOrigin || senderOrigin === "null") senderOrigin = "";
        }

        var token = safeStr(p.token).trim();
        var apiBase = normalizeApiBase(p.apiBase);
        var tokenHeader = parseTokenHeader(p);

        if (EMBEDDED) {
          if (!isTokenOk(token)) return false;
          if (!apiBase) return false;
        } else {
          if (!apiBase) apiBase = normalizeApiBase(window.location.origin);
          if (!isTokenOk(token)) token = "";
          if (p.enforce === undefined) p.enforce = false;
        }

        CFG.token = token;
        CFG.enforce = (p.enforce !== false);
        CFG.apiBase = apiBase;
        CFG.tokenHeader = tokenHeader;

        CFG.allowedOrigins = incomingAllow;
        CFG.urls = isObj(p.urls) ? p.urls : {};

        CFG.heroSrc = normalizeHeroSrc(p.heroSrc || (p.assets && (p.assets.heroSrc || p.assets.hero)) || "");
        if (!CFG.heroSrc) CFG.heroSrc = "/avatar/assets/nyx-hero.webp";

        // LOCK PARENT after first valid config in embedded mode
        if (EMBEDDED && senderOrigin && !LOCKED_PARENT_ORIGIN) LOCKED_PARENT_ORIGIN = senderOrigin;

        exposeConfig();

        setHud("hudBridge", EMBEDDED ? "configured" : "standalone");
        setHud("hudParent", EMBEDDED ? (LOCKED_PARENT_ORIGIN || "—") : "(direct)");
        setHud("hudApi", CFG.apiBase);
        setHud("hudToken", token ? ("set ("+token.length+")") : "missing");
        setHud("hudTokenHeader", CFG.tokenHeader);

        try{ mountShellFromConfig(); }catch(_){}

        // ACK: do NOT echo the raw token back (unnecessary + leaks via parent logs)
        if (EMBEDDED && LOCKED_PARENT_ORIGIN){
          try{
            window.parent.postMessage({
              type: "NYX_ACK",
              payload: {
                ok: true,
                tokenSet: !!CFG.token,
                tokenLen: CFG.token ? CFG.token.length : 0,
                apiBase: CFG.apiBase,
                tokenHeader: CFG.tokenHeader,
                host: window.location.origin,
                heroSrc: CFG.heroSrc
              }
            }, LOCKED_PARENT_ORIGIN);
          }catch(_){}
        }

        return true;
      }

      // ----------------------------
      // Bootstrap fallback (query params / standalone)
      // ----------------------------
      function bootstrapFromQuery(){
        try{
          var qs = new URLSearchParams(window.location.search || "");
          var apiBase = normalizeApiBase(qs.get("apiBase"));
          var token = safeStr(qs.get("token") || "").trim();
          var enforceRaw = safeStr(qs.get("enforce") || "").trim().toLowerCase();
          var enforce = (enforceRaw === "" ? undefined : (enforceRaw === "1" || enforceRaw === "true" || enforceRaw === "yes" || enforceRaw === "on"));
          var heroSrc = normalizeHeroSrc(qs.get("heroSrc") || "");
          var tokenHeader = safeStr(qs.get("tokenHeader") || qs.get("token_header") || "").trim();

          if (apiBase || token || heroSrc || tokenHeader){
            applyConfig({ apiBase: apiBase, token: token, enforce: enforce, heroSrc: heroSrc, tokenHeader: tokenHeader, allowedOrigins: [] }, "");
          } else if (!EMBEDDED) {
            applyConfig({ apiBase: window.location.origin, token: "", enforce: false, heroSrc: "", tokenHeader: "" , allowedOrigins: []}, "");
          }
        }catch(_){
          if (!EMBEDDED) applyConfig({ apiBase: window.location.origin, token: "", enforce: false, heroSrc: "", tokenHeader: "", allowedOrigins: [] }, "");
        }
      }

      // ----------------------------
      // Message receiver (NYX_CONFIG)
      // ----------------------------
      window.addEventListener("message", function(ev){
        var origin = safeStr(ev.origin || "");
        var data = ev.data;

        if (!isObj(data)) return;
        if (data.type !== "NYX_CONFIG") return;

        // Require payload to be an object and contain allowlist when embedded
        var payload = isObj(data.payload) ? data.payload : {};
        if (EMBEDDED && (!Array.isArray(payload.allowedOrigins) || !payload.allowedOrigins.length)) {
          // No allowlist => reject in embed mode
          setHud("hudBridge", "bad_config");
          return;
        }

        var ok = applyConfig(payload, origin);
        if(!ok) setHud("hudBridge", "bad_config");
      });

      // ----------------------------
      // READY signal (safe-ish)
      // ----------------------------
      function signalReady(){
        if (!EMBEDDED){
          setHud("hudBridge", "standalone");
          setHud("hudParent", "(direct)");
          setHud("hudApi", CFG.apiBase || window.location.origin);
          setHud("hudToken", CFG.token ? ("set ("+CFG.token.length+")") : "missing");
          setHud("hudTokenHeader", CFG.tokenHeader || "X-SB-WIDGET-TOKEN");
          return;
        }

        setHud("hudBridge", "ready");

        // Prefer a known/allowed target when possible; otherwise use "*" and rely on allowlist gating on config.
        var target = "*";
        if (CFG.allowedOrigins && CFG.allowedOrigins.length === 1) target = CFG.allowedOrigins[0];
        if (LOCKED_PARENT_ORIGIN) target = LOCKED_PARENT_ORIGIN;

        try{
          window.parent.postMessage({
            type: "NYX_READY",
            payload: { ok:true, host: window.location.origin, href: window.location.href }
          }, target);
        }catch(_){}
      }

      // ----------------------------
      // Chips UI wiring (kept)
      // ----------------------------
      function setActiveChip(chip){
        var rail = window.NYX_HOST_UI.chips;
        if(rail){
          rail.querySelectorAll('.chip').forEach(function(n){ n.classList.remove('is-active'); });
          var active = rail.querySelector('.chip[data-chip="'+chip+'"]');
          if(active) active.classList.add('is-active');
        }
      }

      function openUrlForChip(chip){
        chip = safeStr(chip).toLowerCase();
        var urls = CFG.urls || {};
        var url = safeStr(urls[chip] || "").trim();
        if(!url) return false;
        try{
          window.open(url, "_blank", "noopener,noreferrer");
          return true;
        }catch(_){
          return false;
        }
      }

      function onChipClick(e){
        var el = e.target && e.target.closest ? e.target.closest('[data-chip]') : null;
        if(!el) return;
        var chip = safeStr(el.getAttribute('data-chip') || '').toLowerCase();
        if(!chip) return;

        setActiveChip(chip);

        if (chip === "roku" || chip === "radio" || chip === "schedule") openUrlForChip(chip);
        window.dispatchEvent(new CustomEvent('nyx:chip', { detail: { chip: chip } }));
      }

      var bubbleActions = document.getElementById('nyxBubbleActions');
      if (bubbleActions) bubbleActions.addEventListener('click', onChipClick);
      var chips = document.getElementById('nyxChips');
      if (chips) chips.addEventListener('click', onChipClick);

      // ----------------------------
      // Init
      // ----------------------------
      bootstrapFromQuery();
      signalReady();
      setTimeout(signalReady, 350);
    })();
  </script>
</body>
</html>
