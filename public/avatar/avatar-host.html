<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nyx Avatar Host</title>

<link rel="stylesheet" href="./avatar.css?v=9117" />

<style>
  html,body{height:100%}
  body{margin:0;background:#000;overflow:hidden}

  /* ============================================================
     NYX HOST ‚Äî PREMIUM + HARDENED (FACE-FIRST / DOCKED CARD)
     v9117b (MARION ‚áÑ NYX BRIDGE LOCK++++)
     Fixes:
     ‚úÖ NO "blank slab": flex-card + scroll region (min-height:0)
     ‚úÖ Clamp-based dock sizing (no % - px calc hazards)
     ‚úÖ Chips rail is 1-row with subtle edge fades
     ‚úÖ Input row always visible
     ‚úÖ Expand enlarges dialogue viewport only (not card height)
     ‚úÖ Accept NYX_CAL for hero + dock tuning
     ‚úÖ Marion bridge: payloadLane/payloadAction/payloadIntent/payloadLabel/payloadChip
     ‚úÖ Lane mapping includes schedule + news-canada
     ‚úÖ Origin lock handshake hardened
     ============================================================ */

  :root{
    /* Hero source (host can override via NYX_CONFIG heroSrc) */
    --nyx-hero-abs:url("https://sandblast-backend.onrender.com/avatar/assets/nyx-hero.png");
    --nyx-hero-url:var(--nyx-hero-abs);

    /* Widget framing knobs (calibrated via NYX_CAL) */
    --nyx-hero-pos-x:50%;
    --nyx-hero-pos-y:10%;
    --nyx-hero-scale:132%;
    --nyx-hero-dim:.12;

    /* Card sizing */
    --nyx-card-w: min(448px, calc(100vw - 28px)); /* matches widened widget nicely */
    --nyx-card-radius: 20px;

    /* Card dock position */
    --nyx-card-bottom: 16px;
    --nyx-card-pad: 14px;

    /* Card max height (CLAMP = reliable) */
    --nyx-card-max: clamp(320px, 54vh, 420px);

    /* Typography */
    --nyx-font: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;

    /* Premium glass */
    --nyx-glass-1: rgba(24,24,30,.84);
    --nyx-glass-2: rgba(14,14,20,.92);
    --nyx-line: rgba(255,255,255,.12);
    --nyx-line-soft: rgba(255,255,255,.07);

    /* Accent */
    --nyx-accent: rgba(140,0,35,.92);
    --nyx-accent-soft: rgba(140,0,35,.22);

    /* Dialogue viewport clamp (within scroll area) */
    --nyx-text-max: 118px;         /* collapsed */
    --nyx-text-max-open: 240px;    /* expanded */

    --ease: cubic-bezier(.2,.8,.2,1);
  }

  /* ===== HERO STAGE ===== */
  #nyxStage{
    position:absolute;
    inset:0;
    background-color:#000;
    background-image:var(--nyx-hero-url);
    background-repeat:no-repeat;
    background-size:var(--nyx-hero-scale) auto;
    background-position:var(--nyx-hero-pos-x) var(--nyx-hero-pos-y);
    transition:background-position .2s ease, background-size .2s ease;
    filter:saturate(1.04) contrast(1.02);
  }

  #nyxStage::after{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    opacity:var(--nyx-hero-dim);
    background:
      radial-gradient(120% 100% at 52% 34%, rgba(0,0,0,0) 58%, rgba(0,0,0,.48) 100%),
      linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,.28));
  }

  /* ===== Overlay layout (face-first) ===== */
  #nyxOverlay{
    position:absolute;
    inset:0;
    display:flex;
    flex-direction:column;
    justify-content:flex-end;
    align-items:flex-end;          /* keep card right so face stays clear */
    padding:16px;
    pointer-events:none;
    z-index:10;
  }

  /* Card is interactive */
  #nyxCard, #nyxCard * { pointer-events:auto; }

  /* ===== Docked Card ===== */
  #nyxCard{
    width:var(--nyx-card-w);
    border-radius:var(--nyx-card-radius);
    border:1px solid rgba(255,255,255,.12);

    background:
      radial-gradient(120% 160% at 50% 0%, rgba(255,255,255,.06) 0%, rgba(255,255,255,0) 44%),
      linear-gradient(145deg, var(--nyx-glass-1), var(--nyx-glass-2));

    box-shadow:0 26px 90px rgba(0,0,0,.78);
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);

    padding:var(--nyx-card-pad);
    margin-bottom: var(--nyx-card-bottom);

    /* ‚úÖ reliable sizing */
    max-height: var(--nyx-card-max);
    overflow:hidden;

    /* ‚úÖ critical: flex column so scroll region gets real height */
    display:flex;
    flex-direction:column;
  }

  /* ===== Header row ===== */
  .nyx-head{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:10px;
  }

  .nyx-title{
    font: 650 14px var(--nyx-font);
    letter-spacing:.25px;
    color: rgba(255,255,255,.92);
    display:flex;
    align-items:center;
    gap:10px;
    user-select:none;
  }

  .nyx-dot{
    width:9px;height:9px;border-radius:999px;
    background: var(--nyx-accent);
    box-shadow: 0 0 14px rgba(140,0,35,.45);
  }

  .nyx-head-right{
    display:flex;
    gap:8px;
    align-items:center;
  }

  .nyx-btn{
    font: 12px var(--nyx-font);
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
    color: rgba(255,255,255,.88);
    cursor:pointer;
    user-select:none;
    transition: filter .16s var(--ease), background .16s var(--ease), border-color .16s var(--ease);
    white-space:nowrap;
  }
  .nyx-btn:hover{
    filter: brightness(1.08);
    border-color: rgba(255,255,255,.18);
  }
  .nyx-btn.is-on{
    background: rgba(255,255,255,.08);
    border-color: rgba(255,255,255,.22);
  }

  /* ===== Scroll region ===== */
  #nyxScroll{
    flex: 1 1 auto;
    min-height: 0;              /* ‚úÖ critical for flex scroll */
    overflow:auto;
    padding-right: 4px;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,.18) rgba(0,0,0,0);
  }

  /* ===== Dialogue text ===== */
  #nyxText{
    color: rgba(255,255,255,.96);
    font: 500 15.4px var(--nyx-font);
    line-height: 1.55;
    letter-spacing: .15px;
    white-space: pre-wrap;

    max-height: var(--nyx-text-max);
    overflow:auto;
    padding-right:6px;

    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,.18) rgba(0,0,0,0);
  }

  #nyxCard.is-clamped #nyxText{
    mask-image: linear-gradient(180deg, #000 78%, rgba(0,0,0,0));
    -webkit-mask-image: linear-gradient(180deg, #000 78%, rgba(0,0,0,0));
  }

  #nyxCard.is-open #nyxText{
    max-height: var(--nyx-text-max-open);
    mask-image:none;
    -webkit-mask-image:none;
  }

  .nyx-divider{
    height:1px;
    background: rgba(255,255,255,.06);
    margin:12px 0 12px 0;
  }

  /* ===== Chips rail with premium edge fades ===== */
  .nyx-rail{
    position:relative;
  }
  .nyx-rail::before,
  .nyx-rail::after{
    content:"";
    position:absolute;
    top:0; bottom:0;
    width:22px;
    pointer-events:none;
    opacity:.9;
  }
  .nyx-rail::before{
    left:0;
    background: linear-gradient(90deg, rgba(12,12,16,.95), rgba(12,12,16,0));
  }
  .nyx-rail::after{
    right:0;
    background: linear-gradient(270deg, rgba(12,12,16,.95), rgba(12,12,16,0));
  }

  #nyxChips{
    display:flex;
    flex-wrap:nowrap;
    gap:8px;
    overflow-x:auto;
    overflow-y:hidden;
    padding: 2px 18px 2px 18px; /* space for fades */
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  #nyxChips::-webkit-scrollbar{ display:none; }

  .action-pill{
    flex:0 0 auto;
    font: 12.5px var(--nyx-font);
    padding:8px 12px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.90);
    cursor:pointer;
    user-select:none;
    transition:
      transform .14s var(--ease),
      background .16s var(--ease),
      border-color .16s var(--ease),
      box-shadow .16s var(--ease);
    text-decoration:none;
    white-space:nowrap;
  }

  .action-pill:hover{
    transform: translateY(-1px);
    background: var(--nyx-accent-soft);
    border-color: rgba(140,0,35,.55);
    box-shadow: 0 12px 28px rgba(0,0,0,.35);
  }

  .action-pill.is-active{
    border-color: rgba(140,0,35,.60);
    background: rgba(140,0,35,.22);
  }

  /* ===== Input row ===== */
  .nyx-row{
    display:flex;
    gap:10px;
    margin-top:12px;
  }

  #nyxInput{
    flex:1;
    min-width: 0;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.42);
    color: rgba(255,255,255,.94);
    padding:12px 14px;
    outline:none;
    font: 14px var(--nyx-font);
  }
  #nyxInput::placeholder{ color: rgba(255,255,255,.50); }

  #nyxSend{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.92);
    padding:12px 16px;
    cursor:pointer;
    font: 650 13px var(--nyx-font);
    transition: background .16s var(--ease), border-color .16s var(--ease), filter .16s var(--ease);
    white-space:nowrap;
  }
  #nyxSend:hover{
    background: rgba(140,0,35,.18);
    border-color: rgba(255,255,255,.20);
    filter: brightness(1.04);
  }

  /* ===== Diagnostics (subtle) ===== */
  #nyxDiag{
    margin-top:10px;
    font:12px ui-monospace, Menlo, Consolas, monospace;
    color: rgba(255,255,255,.55);
    user-select:none;
  }

  button:focus, input:focus{
    outline: none;
    box-shadow: 0 0 0 3px rgba(140,0,35,.25);
    border-color: rgba(140,0,35,.55) !important;
  }

  @media (max-width:520px){
    #nyxOverlay{ align-items:center; padding:12px; }
    :root{
      --nyx-card-w: min(460px, calc(100vw - 20px));
      --nyx-card-max: clamp(320px, 58vh, 460px);
      --nyx-text-max: 110px;
      --nyx-text-max-open: 220px;
      --nyx-hero-pos-y: 20%;
      --nyx-hero-scale: 120%;
    }
    .nyx-rail::before,.nyx-rail::after{ width:16px; }
    #nyxChips{ padding-left:14px; padding-right:14px; }
  }

  @media (prefers-reduced-motion: reduce){
    #nyxStage{ transition:none; }
    .action-pill{ transition:none; }
    .nyx-btn{ transition:none; }
  }
</style>
</head>

<body>
  <div id="nyxStage"></div>

  <div id="nyxOverlay">
    <div id="nyxCard" class="is-clamped" role="region" aria-label="Nyx Assistant">
      <div class="nyx-head">
        <div class="nyx-title">
          <span class="nyx-dot" aria-hidden="true"></span>
          <span>Nyx</span>
        </div>

        <div class="nyx-head-right">
          <button class="nyx-btn" id="nyxMic" type="button" aria-label="Mic">üéôÔ∏è</button>
          <button class="nyx-btn" id="nyxVoiceToggle" type="button" aria-label="Voice">üîä Voice</button>
          <button class="nyx-btn" id="nyxExpand" type="button" aria-label="Expand">Expand</button>
        </div>
      </div>

      <div id="nyxScroll">
        <div id="nyxText">Hi‚Ä¶ I‚Äôm Nyx. How are you today?</div>

        <div class="nyx-divider"></div>

        <div class="nyx-rail" aria-hidden="true"></div>
        <div class="nyx-rail">
          <div id="nyxChips" aria-label="Nyx modes">
            <div class="action-pill is-active" data-chip="general">General</div>
            <div class="action-pill" data-chip="music">Music</div>
            <div class="action-pill" data-chip="roku">Roku</div>
            <div class="action-pill" data-chip="schedule">Schedule‚Üó</div>
            <div class="action-pill" data-chip="radio">Radio</div>
            <div class="action-pill" data-chip="news-canada">News Canada‚Üó</div>
          </div>
        </div>

        <div class="nyx-row">
          <input id="nyxInput" type="text" placeholder="Type a message‚Ä¶" autocomplete="off" />
          <button id="nyxSend" type="button">Send</button>
        </div>

        <div id="nyxDiag">HOST v9117b ‚Ä¢ ready</div>
      </div>
    </div>
  </div>

<script>
(function(){
  "use strict";

  // ==========
  // Utilities
  // ==========
  function $(id){ return document.getElementById(id); }
  function safeStr(x){ return (x===null || x===undefined) ? "" : String(x); }
  function safeJsonParse(str){ try { return JSON.parse(str); } catch(e){ return null; } }
  function now(){ return Date.now(); }
  function makeId(){
    try{ if(window.crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(_){}
    return (Math.random().toString(16).slice(2) + now().toString(16)).slice(0, 24);
  }
  function clampToken(s, minLen){
    s = safeStr(s).trim();
    if(!s) return "";
    if(minLen && s.length < minLen) return "";
    if(s.length > 256) s = s.slice(0,256);
    return s;
  }

  // ==========
  // Elements
  // ==========
  var diagEl = $("nyxDiag");
  var cardEl = $("nyxCard");
  var textEl = $("nyxText");
  var expandBtn = $("nyxExpand");
  var chipsEl = $("nyxChips");
  var inputEl = $("nyxInput");
  var sendBtn = $("nyxSend");
  var micBtn = $("nyxMic");
  var voiceBtn = $("nyxVoiceToggle");

  function diag(msg){ if(diagEl) diagEl.textContent = msg; }
  function setText(t){
    if(!textEl) return;
    textEl.textContent = safeStr(t || "");
    try{ textEl.scrollTop = 0; }catch(_){}
  }

  // ==========
  // Bridge hardening
  // ==========
  var PARENT_ORIGIN = null;
  var READY_ACK = false;

  var CONFIG = {
    version: "9117b",
    apiBase: null,
    token: null,
    heroSrc: null,
    voiceDefaultOn: false
  };

  function postToParent(payload, allowWildcard){
    if(!window.parent || window.parent === window) return false;
    try{
      // NEVER wildcard after origin lock (secrets/events)
      var target = PARENT_ORIGIN || (allowWildcard ? "*" : null);
      if(!target) return false;

      // redact tokens if any (defense-in-depth)
      if(payload && typeof payload === "object"){
        if(payload.token) payload = Object.assign({}, payload, { token: "[redacted]" });
        if(payload.packet && payload.packet.__token) payload.packet.__token = "[redacted]";
        if(payload.packet && payload.packet.token) payload.packet.token = "[redacted]";
      }

      window.parent.postMessage(payload, target);
      return true;
    }catch(e){ return false; }
  }

  function sendReady(){
    // handshake ping (no secrets)
    postToParent({ type:"NYX_READY", v:CONFIG.version, ts: now() }, true);
  }

  // READY retry loop (wildcard allowed only until we learn origin)
  var tries = 0;
  var maxTries = 14;
  var readyTimer = setInterval(function(){
    tries++;
    if(READY_ACK || tries > maxTries){
      clearInterval(readyTimer);
      return;
    }
    sendReady();
  }, 250);
  sendReady();

  // ==========
  // Inbound messages (origin lock)
  // ==========
  window.addEventListener("message", function(ev){
    try{
      if(!ev) return;

      // Learn origin from first valid-ish message only
      if(!PARENT_ORIGIN && typeof ev.origin === "string" && ev.origin){
        PARENT_ORIGIN = ev.origin;
        diag("HOST v9117b ‚Ä¢ origin locked");
      }
      if(PARENT_ORIGIN && ev.origin !== PARENT_ORIGIN) return;

      var data = ev.data;
      if(typeof data === "string"){
        var parsed = safeJsonParse(data);
        if(parsed) data = parsed;
      }
      if(!data || typeof data !== "object") return;

      var t = data.type;

      if(t === "NYX_READY_ACK"){
        READY_ACK = true;
        diag("HOST v9117b ‚Ä¢ ready (ack)");
        return;
      }

      if(t === "NYX_CONFIG"){
        var c = (data.config && typeof data.config === "object") ? data.config : {};

        if(typeof c.apiBase === "string") CONFIG.apiBase = safeStr(c.apiBase).trim();
        if(typeof c.token === "string") CONFIG.token = clampToken(c.token, 16);
        if(typeof c.heroSrc === "string") CONFIG.heroSrc = safeStr(c.heroSrc).trim();
        if(typeof c.voiceDefaultOn === "boolean") CONFIG.voiceDefaultOn = c.voiceDefaultOn;

        if(CONFIG.heroSrc){
          document.documentElement.style.setProperty("--nyx-hero-abs", 'url("' + CONFIG.heroSrc + '")');
          document.documentElement.style.setProperty("--nyx-hero-url", 'var(--nyx-hero-abs)');
        }

        if(CONFIG.voiceDefaultOn) setVoice(true);

        if(!CONFIG.token){
          // request token (no wildcard)
          postToParent({ type:"NYX_NEED_TOKEN", v: CONFIG.version, ts: now() }, false);
        }

        diag("HOST v9117b ‚Ä¢ config loaded");
        postToParent({ type:"NYX_CONFIG_ACK", v: CONFIG.version, ts: now() }, false);
        return;
      }

      if(t === "NYX_CAL" && data.cal && typeof data.cal === "object"){
        var cal = data.cal;

        if(typeof cal.heroPosX === "string") document.documentElement.style.setProperty("--nyx-hero-pos-x", cal.heroPosX);
        if(typeof cal.heroPosY === "string") document.documentElement.style.setProperty("--nyx-hero-pos-y", cal.heroPosY);
        if(typeof cal.heroScale === "string") document.documentElement.style.setProperty("--nyx-hero-scale", cal.heroScale);

        if(typeof cal.cardMax === "string") document.documentElement.style.setProperty("--nyx-card-max", cal.cardMax);

        diag("HOST v9117b ‚Ä¢ cal applied");
        return;
      }

      if(t === "NYX_PING"){
        postToParent({ type:"NYX_PONG", v: CONFIG.version, ts: now() }, false);
        return;
      }

      if(t === "NYX_SET_BUBBLE" && typeof data.text === "string"){
        setText(data.text);
        return;
      }

    }catch(_){}
  });

  // ==========
  // Backend client (hardened)
  // ==========
  function apiBase(){
    var b = (CONFIG.apiBase && String(CONFIG.apiBase).trim()) ? String(CONFIG.apiBase).trim() : location.origin;
    return b.replace(/\/+$/,"");
  }

  async function postJson(url, payload, timeoutMs){
    timeoutMs = timeoutMs || 12000;

    var headers = { "Content-Type":"application/json" };

    // Auth (fail-open if missing token; server may still allow)
    if(CONFIG.token){
      headers["Authorization"] = "Bearer " + CONFIG.token;
      headers["X-API-Token"] = CONFIG.token;
    }

    headers["X-Client-Source"] = "nyx_host_iframe";
    headers["X-Route-Hint"] = safeStr(payload && payload.client && payload.client.routeHint ? payload.client.routeHint : UI_STATE.lane);

    var ctrl = new AbortController();
    var to = setTimeout(function(){ try{ ctrl.abort(); }catch(_){} }, timeoutMs);

    try{
      var r = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(payload),
        credentials: "include",
        signal: ctrl.signal
      });

      var txt = await r.text().catch(function(){ return ""; });
      var json = safeJsonParse(txt);

      if(!json){
        return { ok:false, error:"bad_json", status:r.status, raw: txt.slice(0, 600), __httpStatus: r.status };
      }
      json.__httpStatus = r.status;
      return json;

    } catch(e){
      var code = (e && e.name === "AbortError") ? "timeout" : "network";
      return { ok:false, error: code, status: 0, __httpStatus: 0 };
    } finally {
      clearTimeout(to);
    }
  }

  // ==========
  // UI State
  // ==========
  var UI_STATE = {
    lane: "general",
    chip: "general",
    voiceOn: false,
    sttOn: false,
    pending: false,
    lastRequestId: null
  };

  // Marion lane canonicalization (must match marionSO normalizeLaneRaw allowlist)
  function laneFromChip(chip){
    chip = safeStr(chip).toLowerCase().trim();
    if(chip === "general") return "general";
    if(chip === "music") return "music";
    if(chip === "roku") return "roku";
    if(chip === "radio") return "radio";
    if(chip === "schedule") return "schedule";
    if(chip === "news-canada") return "news-canada";
    return "general";
  }

  // ==========
  // Packet builder (MARION BRIDGE CANON)
  // ==========
  function buildIntentPacket(opts){
    opts = (opts && typeof opts === "object") ? opts : {};

    var text = safeStr(opts.text).trim();
    var chip = safeStr(opts.chip || UI_STATE.chip || "general").trim();
    var lane = safeStr(opts.lane || UI_STATE.lane || "general").trim();
    var action = safeStr(opts.action || "").trim();
    var intent = safeStr(opts.intent || "").trim();
    var label = safeStr(opts.label || chip).trim();

    // Default for chip event
    if(!text && !action){
      action = "chip";
      intent = intent || "select";
      label = label || chip;
    }

    var requestId = makeId();

    // Core payload (what your backend already uses)
    var payload = {
      lane: lane,
      action: action || undefined,
      intent: intent || undefined,
      label: label || undefined,
      chip: chip || undefined
    };

    // turnSignals mirror (what marionSO reads first)
    var turnSignals = {
      hasPayload: true,
      textEmpty: !text,
      payloadActionable: true,
      payloadLane: lane,
      payloadAction: action || "",
      payloadIntent: intent || "",
      payloadLabel: label || "",
      payloadChip: chip || ""
    };

    return {
      requestId: requestId,
      text: text,
      lane: lane,           // convenience mirror
      action: action,       // convenience mirror
      payload: payload,
      turnSignals: turnSignals,

      client: {
        source: "nyx_host_iframe",
        routeHint: lane,
        chip: chip
      }
    };
  }

  function setPending(on){
    UI_STATE.pending = !!on;
    if(sendBtn) sendBtn.disabled = UI_STATE.pending;
    if(inputEl) inputEl.disabled = UI_STATE.pending;
  }

  // ==========
  // Expand/Collapse
  // ==========
  var isExpanded = false;
  function applyClampUI(){
    if(!cardEl) return;
    cardEl.classList.toggle("is-open", isExpanded);
    cardEl.classList.toggle("is-clamped", !isExpanded);
    if(expandBtn) expandBtn.textContent = isExpanded ? "Collapse" : "Expand";
  }

  if(expandBtn){
    expandBtn.addEventListener("click", function(){
      isExpanded = !isExpanded;
      applyClampUI();
    });
  }
  applyClampUI();

  // ==========
  // Chips
  // ==========
  function setActiveChip(chip){
    UI_STATE.chip = chip;
    UI_STATE.lane = laneFromChip(chip);

    if(chipsEl){
      var pills = chipsEl.querySelectorAll(".action-pill");
      for(var i=0;i<pills.length;i++){
        var p = pills[i];
        var c = p.getAttribute("data-chip");
        p.classList.toggle("is-active", c === chip);
      }
    }
  }

  function openLinkForChip(chip){
    // Parent decides what ‚ÄúSchedule‚Üó‚Äù and ‚ÄúNews Canada‚Üó‚Äù do.
    postToParent({ type:"NYX_NAV", where: chip, lane: laneFromChip(chip), ts: now() }, false);
  }

  function handleChipClick(chip){
    chip = safeStr(chip).trim();
    if(!chip) return;

    // External nav-only chips
    if(chip === "schedule" || chip === "news-canada"){
      setActiveChip(chip); // still set lane so future text uses correct lane if you want it
      openLinkForChip(chip);
      return;
    }

    setActiveChip(chip);

    // CHIP SELECT ‚Üí Marion BRIDGE path (payload.action="chip")
    var packet = buildIntentPacket({
      text: "",
      chip: chip,
      lane: UI_STATE.lane,
      action: "chip",
      intent: "select",
      label: chip
    });

    postToParent({ type:"NYX_CHIP", v:CONFIG.version, ts:now(), chip: chip, lane: UI_STATE.lane }, false);
    return sendPacket(packet);
  }

  if(chipsEl){
    chipsEl.addEventListener("click", function(e){
      try{
        var t = e.target;
        while(t && t !== chipsEl && !(t.classList && t.classList.contains("action-pill"))){
          t = t.parentNode;
        }
        if(!t || t === chipsEl) return;
        var chip = t.getAttribute("data-chip");
        if(!chip) return;
        handleChipClick(chip);
      }catch(_){}
    });
  }
  setActiveChip("general");

  // ==========
  // Voice
  // ==========
  function setVoice(on){
    UI_STATE.voiceOn = !!on;
    if(voiceBtn) voiceBtn.classList.toggle("is-on", UI_STATE.voiceOn);
  }

  function stopAudio(){
    try{
      if(window.__NYX_AUDIO && typeof window.__NYX_AUDIO.pause === "function"){
        window.__NYX_AUDIO.pause();
        window.__NYX_AUDIO.currentTime = 0;
      }
    }catch(_){}
  }

  async function speak(text){
    if(!UI_STATE.voiceOn) return;
    var s = safeStr(text).trim();
    if(!s) return;

    stopAudio();

    try{
      var url = apiBase() + "/api/tts";
      var headers = { "Content-Type":"application/json" };
      if(CONFIG.token){
        headers["Authorization"] = "Bearer " + CONFIG.token;
        headers["X-API-Token"] = CONFIG.token;
      }

      var ctrl = new AbortController();
      var to = setTimeout(function(){ try{ ctrl.abort(); }catch(_){} }, 12000);

      var r = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify({ text: s }),
        credentials: "include",
        signal: ctrl.signal
      }).catch(function(){ return null; });

      clearTimeout(to);
      if(!r || !r.ok) return;

      var buf = await r.arrayBuffer();
      var blob = new Blob([buf], { type: "audio/mpeg" });
      var objUrl = URL.createObjectURL(blob);

      var a = new Audio(objUrl);
      window.__NYX_AUDIO = a;
      a.onended = function(){ try{ URL.revokeObjectURL(objUrl); }catch(_){ } };
      a.play().catch(function(){});
    }catch(_){}
  }

  if(voiceBtn){
    voiceBtn.addEventListener("click", function(){
      setVoice(!UI_STATE.voiceOn);
      if(!UI_STATE.voiceOn) stopAudio();
      postToParent({ type:"NYX_VOICE_TOGGLE", v:CONFIG.version, ts:now(), on: UI_STATE.voiceOn }, false);
    });
  }

  // ==========
  // STT
  // ==========
  var SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;
  var rec = null;

  function setMic(on){
    UI_STATE.sttOn = !!on;
    if(micBtn) micBtn.classList.toggle("is-on", UI_STATE.sttOn);
  }

  function stopSTT(){
    try{
      if(rec){
        rec.onresult = null; rec.onerror = null; rec.onend = null;
        rec.stop();
      }
    }catch(_){}
    setMic(false);
  }

  function startSTT(){
    if(!SpeechRecognition){ diag("HOST v9117b ‚Ä¢ STT unsupported"); return; }
    if(UI_STATE.pending) return;

    if(!rec){
      rec = new SpeechRecognition();
      rec.continuous = false;
      rec.interimResults = false;
      rec.lang = "en-US";
    }

    rec.onresult = function(ev){
      try{
        var t = "";
        if(ev && ev.results && ev.results[0] && ev.results[0][0]){
          t = safeStr(ev.results[0][0].transcript).trim();
        }
        if(t){
          if(inputEl) inputEl.value = t;
          sendTypedText();
        }
      }catch(_){}
    };

    rec.onerror = function(){ stopSTT(); diag("HOST v9117b ‚Ä¢ STT error"); };
    rec.onend = function(){ setMic(false); };

    try{ rec.start(); setMic(true); diag("HOST v9117b ‚Ä¢ listening‚Ä¶"); }catch(_){ setMic(false); }
  }

  if(micBtn){
    micBtn.addEventListener("click", function(){
      if(UI_STATE.sttOn) stopSTT(); else startSTT();
      postToParent({ type:"NYX_MIC_TOGGLE", v:CONFIG.version, ts:now(), on: UI_STATE.sttOn }, false);
    });
  }

  // ==========
  // Send pipeline
  // ==========
  async function sendPacket(packet){
    UI_STATE.lastRequestId = safeStr(packet && packet.requestId);
    setPending(true);
    diag("HOST v9117b ‚Ä¢ sending‚Ä¶");

    // Telemetry to parent (sanitized)
    postToParent({ type:"NYX_OUTBOUND", v:CONFIG.version, ts:now(), packet: { requestId: packet.requestId, lane: packet.lane, action: packet.action, client: packet.client, turnSignals: packet.turnSignals } }, false);

    var url = apiBase() + "/api/chat";
    var out = await postJson(url, packet, 12000);

    var status = Number(out && (out.__httpStatus || out.status || 0)) || 0;

    if(out && typeof out.reply === "string" && out.reply){
      setText(out.reply);
      speak(out.reply);
      postToParent({ type:"NYX_REPLY", v:CONFIG.version, ts:now(), reply: out.reply, meta: out.meta || {} }, false);
      diag("HOST v9117b ‚Ä¢ ok");
    }else{
      var msg = "Hmm. I didn‚Äôt get a clean reply. Try again.";
      if(status === 401 || status === 403) msg = "Auth blocked (401/403). Token/origin mismatch ‚Äî fix the parent config.";
      if(out && out.error === "timeout") msg = "Timeout. Try again.";
      setText(msg);

      diag("HOST v9117b ‚Ä¢ error " + (status || "unknown"));
      postToParent({ type:"NYX_ERROR", v:CONFIG.version, ts:now(), status: status, error: (out && out.error) || "error", meta: out && out.meta ? out.meta : {} }, false);
    }

    setPending(false);
    return out;
  }

  function sendTypedText(){
    var text = (inputEl && inputEl.value) ? String(inputEl.value).trim() : "";
    if(!text) return;

    var packet = buildIntentPacket({
      text: text,
      chip: UI_STATE.chip,
      lane: UI_STATE.lane,
      action: "user_text",
      intent: "message",
      label: UI_STATE.chip
    });

    if(inputEl) inputEl.value = "";
    return sendPacket(packet);
  }

  if(sendBtn){
    sendBtn.addEventListener("click", function(){ sendTypedText(); });
  }
  if(inputEl){
    inputEl.addEventListener("keydown", function(e){
      if(e.key === "Enter"){
        e.preventDefault();
        sendTypedText();
      }
    });
  }

})();
</script>
</body>
</html>
