<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nyx Avatar Host</title>

  <!-- Use the real skin -->
  <link rel="stylesheet" href="./avatar.css" />

  <!-- Host-only tiny layout helpers (kept minimal; aesthetics live in avatar.css) -->
  <style>
    /* HARD CANVAS (critical): make iframe content NOT transparent */
    html,body{height:100%}
    body{
      margin:0;
      background:#000; /* true black base to match avatar.css v1.0.7 */
    }

    #wrap{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:12px;
      padding:12px;
      height:100vh;
      box-sizing:border-box;
    }

    #avatarRoot{
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      overflow:hidden;
      min-height:420px;
      position:relative;

      /* HARD CANVAS (critical): avoid “see-through” blend collapse */
      background:#000; /* seamless black */
    }

    #panel{
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      padding:12px;

      /* darken to match the rest; no gray wash */
      background:#000;
    }

    .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}

    textarea{
      width:100%;
      box-sizing:border-box;
      background:#0b0b10;
      color:#fff;
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      padding:10px;
    }

    .hud{font:12px ui-monospace,Menlo,Consolas,monospace;opacity:.9;line-height:1.5}
    .hud b{opacity:.85}

    button{
      background:#0b0b10;
      color:#fff;
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px;
      padding:8px 10px;
      cursor:pointer;
    }
    button:hover{ border-color: rgba(255,255,255,.22); }

    /* Overlay layer inside avatarRoot */
    .overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:20;
    }
    .overlay-inner{
      position:absolute;
      left:0; right:0;
      bottom:14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      padding:0 12px;
      pointer-events:none;
    }
    .overlay-inner .bubble,
    .overlay-inner .chip,
    .overlay-inner .action-pill{
      pointer-events:auto;
    }
    .is-hidden{ display:none !important; }

    /* Ensure the avatar stage is centered nicely */
    #nyxShellMount{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:10;
    }

    /* Embedded mode: hide debug panel + tighten grid */
    .embed #wrap{
      grid-template-columns: 1fr;
      padding:0;
      height:100vh;
    }
    .embed #panel{ display:none; }
    .embed #avatarRoot{
      border-radius:0;
      border:0;
      height:100vh;
      min-height:100vh;
      background:#000; /* keep solid in embed */
    }
  </style>
</head>

<body>
  <div id="wrap">

    <!-- LEFT: Avatar stage -->
    <div id="avatarRoot">

      <!-- Guaranteed mount target + fallback avatar DOM.
           Shell can enhance/replace this; but even if shell fails, you SEE Nyx. -->
      <div id="nyxShellMount">
        <div class="avatar gaze-soft mood-attentive" id="nyxAvatar">
          <div class="silhouette">
            <div class="head">
              <div class="eye left">
                <div class="pupil"></div>
                <div class="lid"></div>
              </div>
              <div class="eye right">
                <div class="pupil"></div>
                <div class="lid"></div>
              </div>
              <div class="mouth"></div>
            </div>
            <div class="shoulders"></div>
          </div>
        </div>
      </div>

      <!-- Overlay UI (bubble + chips) -->
      <div class="overlay" id="nyxOverlay">
        <div class="overlay-inner">

          <div class="bubble" id="nyxBubble">
            <div class="bubble-text" id="nyxBubbleText">
              Hi… I’m Nyx. How are you today?
            </div>

            <div class="bubble-actions" id="nyxBubbleActions">
              <div class="action-pill general" data-chip="general">General</div>
              <div class="action-pill" data-chip="music">Music</div>
              <div class="action-pill" data-chip="roku">Roku</div>
              <div class="action-pill schedule" data-chip="schedule">Schedule<span class="ext">↗</span></div>
              <div class="action-pill" data-chip="radio">Radio</div>
            </div>
          </div>

          <div class="chips" id="nyxChips">
            <div class="chip is-active" data-chip="general">General</div>
            <div class="chip" data-chip="music">Music</div>
            <div class="chip" data-chip="roku">Roku</div>
            <div class="chip" data-chip="schedule">Schedule<span class="ext">↗</span></div>
            <div class="chip" data-chip="radio">Radio</div>
          </div>

        </div>
      </div>
    </div>

    <!-- RIGHT: Debug + manual controls (auto-hidden when embedded) -->
    <div id="panel">
      <div class="row">
        <button data-act="armAudio">Arm Audio</button>
        <button data-act="idle">Idle</button>
        <button data-act="listen">Listen</button>
        <button data-act="speak">Speak</button>
        <button data-act="toggleVelvet">Velvet</button>
      </div>

      <textarea id="prompt" rows="4" placeholder="Type a message…"></textarea>
      <div class="row">
        <button data-act="sendChat">Send /api/chat</button>
        <button data-act="speakText">Speak /api/tts</button>
      </div>

      <div class="hud">
        <div><b>presence</b>: <span id="hudPresence">idle</span></div>
        <div><b>stage</b>: <span id="hudStage">warm</span></div>
        <div><b>dominance</b>: <span id="hudDom">neutral</span></div>
        <div><b>velvet</b>: <span id="hudVelvet">0</span></div>
        <div><b>anim</b>: <span id="hudAnim"></span></div>
        <div><b>amp</b>: <span id="hudAmp">0.00</span></div>
        <div style="margin-top:10px;opacity:.9">
          <b>bridge</b>: <span id="hudBridge">waiting</span><br/>
          <b>parent</b>: <span id="hudParent">—</span><br/>
          <b>apiBase</b>: <span id="hudApi">—</span><br/>
          <b>token</b>: <span id="hudToken">—</span><br/>
          <b>tokenHeader</b>: <span id="hudTokenHeader">—</span><br/>
          <b>hostVer</b>: <span id="hudHostVer">—</span>
        </div>
      </div>

      <audio id="nyxAudio" preload="auto" style="display:none"></audio>
    </div>

  </div>

  <!-- IMPORTANT: keep these relative so /avatar/avatar-host.html serves them correctly -->
  <script src="./avatar-contract.js"></script>
  <script src="./nyx-avatar-shell.js"></script>
  <script src="./avatar-controller.js"></script>
  <script src="./avatar-bridge.js"></script>

  <script>
    (function(){
      // ============================
      // Avatar Host Hardening (FULL)
      // ============================

      var HOST_VER = "avatar-host v1.0.7 (seamless black + bubble alive hooks + safe standalone)";
      try{ console.log("[NyxHost]", HOST_VER); }catch(_){}

      var EMBEDDED = false;
      try{ EMBEDDED = (window.top !== window.self); }
      catch(_){ EMBEDDED = true; }
      if (EMBEDDED) document.documentElement.classList.add('embed');

      window.NYX_HOST_UI = {
        root: document.getElementById('avatarRoot'),
        overlay: document.getElementById('nyxOverlay'),
        bubble: document.getElementById('nyxBubble'),
        bubbleText: document.getElementById('nyxBubbleText'),
        bubbleActions: document.getElementById('nyxBubbleActions'),
        chips: document.getElementById('nyxChips')
      };

      function safeStr(x){ return (x===null||x===undefined) ? "" : String(x); }
      function isObj(x){ return !!x && typeof x === "object" && !Array.isArray(x); }

      function setHud(id, val){
        var el = document.getElementById(id);
        if(el) el.textContent = safeStr(val || "—");
      }

      function isTokenOk(t){
        t = safeStr(t).trim();
        return t.length >= 12;
      }

      function normalizeApiBase(s){
        s = safeStr(s).trim().replace(/\/+$/,"");
        return s;
      }

      function normalizeHeroSrc(src){
        src = safeStr(src).trim();
        if(!src) return "";
        if (/^file:\/\//i.test(src)) return "";
        if (/^https?:\/\//i.test(src)) return src;
        if (src[0] !== "/") src = "/" + src;
        return src;
      }

      function preloadImage(src){
        src = normalizeHeroSrc(src);
        if(!src) return;
        try{
          var img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.src = src;
        }catch(_){}
      }

      function originOf(urlStr){
        try{ return new URL(urlStr, window.location.href).origin; }
        catch(_){ return ""; }
      }

      function mountShellFromConfig(heroSrc){
        try{
          var mountEl = document.getElementById("nyxShellMount");
          if(!mountEl) return;

          var hero = normalizeHeroSrc(heroSrc || "");
          if (hero) preloadImage(hero);

          if (window.NyxAvatarShell && typeof window.NyxAvatarShell.getInstance === "function") {
            var inst = window.NyxAvatarShell.getInstance();
            if (inst && inst.el && inst.el.parentNode) {
              try{
                if (hero && typeof inst.setHero === "function") inst.setHero(hero);
                if (hero && typeof inst.setHeroSrc === "function") inst.setHeroSrc(hero);
                if (hero && typeof inst.applyDirective === "function") inst.applyDirective({ heroSrc: hero });
              }catch(_){}
              return;
            }
          }

          if(!window.NyxAvatarShell || typeof window.NyxAvatarShell.mount !== "function") return;
          window.NyxAvatarShell.mount(mountEl, { heroSrc: hero || "" });
        }catch(_){}
      }

      // ----------------------------
      // Bubble "alive" hooks
      // ----------------------------
      var _bubbleTimer = null;

      function bubbleTyping(on){
        try{
          var b = window.NYX_HOST_UI.bubble;
          if(!b) return;
          if(on) b.classList.add("typing");
          else b.classList.remove("typing");
        }catch(_){}
      }

      function bubblePop(){
        try{
          var b = window.NYX_HOST_UI.bubble;
          if(!b) return;
          b.classList.remove("pop");
          // force reflow so animation re-triggers
          void b.offsetWidth;
          b.classList.add("pop");
          clearTimeout(_bubbleTimer);
          _bubbleTimer = setTimeout(function(){
            try{ b.classList.remove("pop"); }catch(_){}
          }, 320);
        }catch(_){}
      }

      function setBubbleText(text, opts){
        opts = opts || {};
        var t = window.NYX_HOST_UI.bubbleText;
        if(!t) return;
        t.textContent = safeStr(text || "");
        if(opts.pop) bubblePop();
        if(opts.typing === true) bubbleTyping(true);
        if(opts.typing === false) bubbleTyping(false);
      }

      // Expose a small API so Marion/bridge/controller can animate bubble without importing anything
      window.NYX_UI = {
        setBubbleText: setBubbleText,
        bubbleTyping: bubbleTyping,
        bubblePop: bubblePop
      };

      // ----------------------------
      // Bridge policy
      // ----------------------------
      var ALLOWED_PARENT_ORIGINS = [
        "https://sandblast.channel",
        "https://www.sandblast.channel"
      ];

      var ALLOWED_API_ORIGINS = [
        "https://sandblast-backend.onrender.com",
        "https://sandblast.channel",
        "https://www.sandblast.channel"
      ];

      function parentOriginAllowed(origin){
        if(!origin || origin === "null") return false;
        for (var i=0;i<ALLOWED_PARENT_ORIGINS.length;i++){
          if (safeStr(ALLOWED_PARENT_ORIGINS[i]) === origin) return true;
        }
        return false;
      }

      function apiOriginAllowed(origin){
        if(!origin || origin === "null") return false;
        for (var i=0;i<ALLOWED_API_ORIGINS.length;i++){
          if (safeStr(ALLOWED_API_ORIGINS[i]) === origin) return true;
        }
        return false;
      }

      var CFG = {
        enforce: true,
        apiBase: "",
        apiOrigin: "",
        urls: {},
        heroSrc: "",
        tokenHeader: "X-SB-WIDGET-TOKEN"
      };

      var _TOKEN = "";
      var LOCKED_PARENT_ORIGIN = "";

      var READY_NONCE = "";
      function genNonce(){
        try{
          var a = new Uint8Array(16);
          (window.crypto || {}).getRandomValues && window.crypto.getRandomValues(a);
          var s = "";
          for (var i=0;i<a.length;i++) s += ("0"+a[i].toString(16)).slice(-2);
          return s;
        }catch(_){}
        return String(Date.now()) + "_" + Math.random().toString(16).slice(2);
      }
      READY_NONCE = genNonce();

      function parseTokenHeader(p){
        var h = safeStr(p.tokenHeader || p.token_header || p.tokenHeaderName || "").trim();
        if(!h) h = "X-SB-WIDGET-TOKEN";
        if (/[\s\r\n\t]/.test(h)) h = "X-SB-WIDGET-TOKEN";
        return h;
      }

      function showBlocked(reason){
        setHud("hudBridge", "blocked");
        try{
          setBubbleText("Nyx isn’t configured yet ("+safeStr(reason)+").", { pop:true, typing:false });
        }catch(_){}
      }

      var _nativeFetch = window.fetch ? window.fetch.bind(window) : null;

      function resolveUrl(input){
        try{
          if (typeof input === "string") return input;
          if (input && typeof input === "object" && input.url) return String(input.url);
        }catch(_){}
        return "";
      }

      function canonicalizeApiish(urlStr){
        var u = safeStr(urlStr).trim();
        if (/^api\//i.test(u)) return "/" + u;
        return u;
      }

      function isApiRequest(urlStr){
        urlStr = canonicalizeApiish(urlStr);
        if (/^\/api\//i.test(urlStr)) return true;

        try{
          var abs = new URL(urlStr, window.location.href);
          if (abs.pathname.indexOf("/api/") !== 0) return false;
          if (CFG.apiOrigin) return abs.origin === CFG.apiOrigin;
          return abs.origin === window.location.origin;
        }catch(_){}
        return false;
      }

      function injectTokenHeaders(init){
        init = init || {};
        var headers = init.headers;

        var out = {};
        try{
          if (headers && typeof Headers !== "undefined" && headers instanceof Headers){
            headers.forEach(function(v,k){ out[k] = v; });
          } else if (Array.isArray(headers)){
            headers.forEach(function(pair){
              if (Array.isArray(pair) && pair.length >= 2) out[String(pair[0])] = String(pair[1]);
            });
          } else if (headers && typeof headers === "object"){
            Object.keys(headers).forEach(function(k){ out[k] = headers[k]; });
          }
        }catch(_){}

        var key = CFG.tokenHeader || "X-SB-WIDGET-TOKEN";
        var token = _TOKEN;

        if (token){
          var has = false;
          Object.keys(out).forEach(function(k){
            if (String(k).toLowerCase() === String(key).toLowerCase()) has = true;
          });
          if (!has) out[key] = token;
        }

        var hasCT = false;
        Object.keys(out).forEach(function(k){
          if (String(k).toLowerCase() === "content-type") hasCT = true;
        });
        if (!hasCT) out["Content-Type"] = "application/json";

        init.headers = out;
        return init;
      }

      function nyxFetch(input, init){
        if (!_nativeFetch) throw new Error("fetch_not_supported");
        if (CFG.enforce && !_TOKEN) {
          showBlocked("token_missing");
          return Promise.reject(new Error("nyx_token_missing"));
        }
        var url = resolveUrl(input);
        if (isApiRequest(url)) init = injectTokenHeaders(init);
        return _nativeFetch(input, init);
      }

      window.NYX_FETCH = nyxFetch;
      window.NYX_TOKEN_HEADER = function(){ return CFG.tokenHeader || "X-SB-WIDGET-TOKEN"; };

      if (_nativeFetch){
        window.fetch = function(input, init){
          try{
            var url = resolveUrl(input);
            if (isApiRequest(url)) return nyxFetch(input, init);
          }catch(_){}
          return _nativeFetch(input, init);
        };
      }

      function exposeConfig(){
        window.NYX_CONFIG = {
          enforce: CFG.enforce,
          apiBase: CFG.apiBase,
          apiOrigin: CFG.apiOrigin,
          urls: Object.assign({}, CFG.urls || {}),
          heroSrc: CFG.heroSrc || "",
          tokenHeader: CFG.tokenHeader || "X-SB-WIDGET-TOKEN",
          tokenSet: !!_TOKEN,
          tokenLen: _TOKEN ? _TOKEN.length : 0,
          parentLocked: !!LOCKED_PARENT_ORIGIN,
          hostVer: HOST_VER
        };

        window.NYX_API_BASE = CFG.apiBase;

        window.dispatchEvent(new CustomEvent("nyx:config", { detail: window.NYX_CONFIG }));
      }

      function applyConfig(payload, senderOrigin){
        var p = isObj(payload) ? payload : {};

        if (EMBEDDED){
          if (LOCKED_PARENT_ORIGIN) {
            if (senderOrigin !== LOCKED_PARENT_ORIGIN) return false;
          } else {
            if (!parentOriginAllowed(senderOrigin)) return false;
          }
        }

        if (EMBEDDED){
          var n = safeStr(p.nonce || p.readyNonce || "").trim();
          if (!n || n !== READY_NONCE) return false;
        }

        var apiBase = normalizeApiBase(p.apiBase);
        if (!apiBase) return false;

        var apiOrigin = originOf(apiBase);
        if (!apiOriginAllowed(apiOrigin)) return false;

        var token = safeStr(p.token).trim();
        var enforce = (p.enforce !== false);

        if (EMBEDDED && enforce){
          if (!isTokenOk(token)) return false;
        } else {
          if (!isTokenOk(token)) token = "";
        }

        var tokenHeader = parseTokenHeader(p);

        CFG.enforce = enforce;
        CFG.apiBase = apiBase;
        CFG.apiOrigin = apiOrigin;
        CFG.tokenHeader = tokenHeader;

        CFG.urls = isObj(p.urls) ? p.urls : {};

        CFG.heroSrc = normalizeHeroSrc(p.heroSrc || (p.assets && (p.assets.heroSrc || p.assets.hero)) || "");
        if (!CFG.heroSrc) CFG.heroSrc = "/avatar/assets/nyx-hero.webp";

        _TOKEN = token;

        if (EMBEDDED && senderOrigin && !LOCKED_PARENT_ORIGIN) LOCKED_PARENT_ORIGIN = senderOrigin;

        setHud("hudBridge", EMBEDDED ? "configured" : "standalone");
        setHud("hudParent", EMBEDDED ? (LOCKED_PARENT_ORIGIN || "—") : "(direct)");
        setHud("hudApi", CFG.apiBase);
        setHud("hudToken", _TOKEN ? ("set ("+_TOKEN.length+")") : (CFG.enforce ? "missing (blocked)" : "missing"));
        setHud("hudTokenHeader", CFG.tokenHeader);
        setHud("hudHostVer", HOST_VER);

        exposeConfig();
        try{ mountShellFromConfig(CFG.heroSrc); }catch(_){}

        // Kick the bubble into "alive" mode briefly after config lands
        try{
          bubbleTyping(true);
          setTimeout(function(){
            bubbleTyping(false);
            bubblePop();
          }, 380);
        }catch(_){}

        if (EMBEDDED && LOCKED_PARENT_ORIGIN){
          try{
            window.parent.postMessage({
              type: "NYX_ACK",
              payload: {
                ok: true,
                tokenSet: !!_TOKEN,
                tokenLen: _TOKEN ? _TOKEN.length : 0,
                apiBase: CFG.apiBase,
                apiOrigin: CFG.apiOrigin,
                tokenHeader: CFG.tokenHeader,
                host: window.location.origin,
                heroSrc: CFG.heroSrc,
                hostVer: HOST_VER
              }
            }, LOCKED_PARENT_ORIGIN);
          }catch(_){}
        }

        return true;
      }

      function bootstrapFromQuery(){
        if (EMBEDDED) return;

        try{
          var qs = new URLSearchParams(window.location.search || "");
          var apiBase = normalizeApiBase(qs.get("apiBase"));
          var token = safeStr(qs.get("token") || "").trim();
          var enforceRaw = safeStr(qs.get("enforce") || "").trim().toLowerCase();
          var enforce = (enforceRaw === "" ? false : (enforceRaw === "1" || enforceRaw === "true" || enforceRaw === "yes" || enforceRaw === "on"));
          var heroSrc = normalizeHeroSrc(qs.get("heroSrc") || "");
          var tokenHeader = safeStr(qs.get("tokenHeader") || qs.get("token_header") || "").trim();

          if (apiBase){
            var apiOrigin = originOf(apiBase);
            if (!apiOriginAllowed(apiOrigin)) apiBase = normalizeApiBase(window.location.origin);
          } else {
            apiBase = normalizeApiBase(window.location.origin);
          }

          applyConfig({
            apiBase: apiBase,
            token: token,
            enforce: enforce,
            heroSrc: heroSrc,
            tokenHeader: tokenHeader,
            nonce: READY_NONCE
          }, "");
        }catch(_){
          applyConfig({
            apiBase: normalizeApiBase(window.location.origin),
            token: "",
            enforce: false,
            heroSrc: "",
            tokenHeader: "",
            nonce: READY_NONCE
          }, "");
        }
      }

      window.addEventListener("message", function(ev){
        var origin = safeStr(ev.origin || "");
        var data = ev.data;

        if (!isObj(data)) return;
        if (data.type !== "NYX_CONFIG") return;

        var payload = isObj(data.payload) ? data.payload : {};

        var ok = applyConfig(payload, origin);
        if(!ok){
          setHud("hudBridge", "bad_config");
          setHud("hudHostVer", HOST_VER);
          if (EMBEDDED) showBlocked("bad_config");
        }
      });

      function signalReady(){
        setHud("hudHostVer", HOST_VER);

        if (!EMBEDDED){
          setHud("hudBridge", "standalone");
          setHud("hudParent", "(direct)");
          setHud("hudApi", CFG.apiBase || window.location.origin);
          setHud("hudToken", _TOKEN ? ("set ("+_TOKEN.length+")") : "missing");
          setHud("hudTokenHeader", CFG.tokenHeader || "X-SB-WIDGET-TOKEN");
          return;
        }

        setHud("hudBridge", "ready");

        try{
          window.parent.postMessage({
            type: "NYX_READY",
            payload: {
              ok: true,
              nonce: READY_NONCE,
              host: window.location.origin,
              href: window.location.href,
              hostVer: HOST_VER
            }
          }, "*");
        }catch(_){}
      }

      function setActiveChip(chip){
        var rail = window.NYX_HOST_UI.chips;
        if(rail){
          rail.querySelectorAll('.chip').forEach(function(n){ n.classList.remove('is-active'); });
          var active = rail.querySelector('.chip[data-chip="'+chip+'"]');
          if(active) active.classList.add('is-active');
        }
      }

      function openUrlForChip(chip){
        chip = safeStr(chip).toLowerCase();
        var urls = CFG.urls || {};
        var url = safeStr(urls[chip] || "").trim();
        if(!url) return false;
        try{
          window.open(url, "_blank", "noopener,noreferrer");
          return true;
        }catch(_){
          return false;
        }
      }

      function onChipClick(e){
        var el = e.target && e.target.closest ? e.target.closest('[data-chip]') : null;
        if(!el) return;
        var chip = safeStr(el.getAttribute('data-chip') || '').toLowerCase();
        if(!chip) return;

        setActiveChip(chip);

        if (chip === "roku" || chip === "radio" || chip === "schedule") openUrlForChip(chip);
        window.dispatchEvent(new CustomEvent('nyx:chip', { detail: { chip: chip } }));
      }

      var bubbleActions = document.getElementById('nyxBubbleActions');
      if (bubbleActions) bubbleActions.addEventListener('click', onChipClick);
      var chips = document.getElementById('nyxChips');
      if (chips) chips.addEventListener('click', onChipClick);

      // If other scripts want to show “typing”, give them a signal:
      window.addEventListener("nyx:typing", function(ev){
        try{ bubbleTyping(!!(ev && ev.detail && ev.detail.on)); }catch(_){}
      });
      window.addEventListener("nyx:bubble", function(ev){
        try{
          var d = (ev && ev.detail) ? ev.detail : {};
          setBubbleText(d.text || "", { pop: d.pop !== false, typing: (d.typing===true ? true : (d.typing===false ? false : undefined)) });
        }catch(_){}
      });

      bootstrapFromQuery();
      signalReady();
      setTimeout(signalReady, 350);

      if (EMBEDDED) showBlocked("waiting_config");
    })();
  </script>
</body>
</html>
