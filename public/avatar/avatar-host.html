<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nyx Avatar Host</title>

<link rel="stylesheet" href="./avatar.css?v=9117" />

<style>
  html,body{height:100%}
  body{margin:0;background:#000;overflow:hidden}

  /* ============================================================
     NYX HOST ‚Äî PREMIUM + HARDENED (FACE-FIRST / DOCKED CARD)
     v9117l (CHIPS FIT++++ + TRANSCRIPT (EXPAND-ONLY)++++ + INTRO VOICE UNLOCK++++
             + LANE HARD-LOCK++++ + DEBUG SURFACE KILLED++++ + ROKU LINKS++++)
     Notes:
     - Avatar framing is HARD-LOCKED: hero stage logic preserved.
     - Cog badge (Lane:music etc) is now DOUBLE-GATED: ?debug=1 AND config.debug=true.
     ============================================================ */

  :root{
    /* Default hero: MP4 */
    --nyx-hero-video: "https://sandblast-backend.onrender.com/avatar/assets/avatar3.mp4";
    /* Default image fallback (poster / bg) */
    --nyx-hero-img-url: "https://sandblast-backend.onrender.com/avatar/assets/nyx-hero.png";

    /* Widget framing knobs (calibrated via NYX_CAL) ‚Äî HARD LOCKED */
    --nyx-hero-pos-x:50%;
    --nyx-hero-pos-y:10%;
    --nyx-hero-scale-num: 1.32;
    --nyx-hero-dim:.12;

    /* Card sizing */
    --nyx-card-w: min(448px, calc(100vw - 28px));
    --nyx-card-radius: 20px;
    --nyx-card-bottom: 16px;
    --nyx-card-pad: 14px;
    --nyx-card-max: clamp(320px, 54vh, 440px);

    /* Typography */
    --nyx-font: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;

    /* Premium glass */
    --nyx-glass-1: rgba(24,24,30,.76);
    --nyx-glass-2: rgba(14,14,20,.86);

    /* Accent */
    --nyx-accent: rgba(140,0,35,.92);
    --nyx-accent-soft: rgba(140,0,35,.22);

    /* Dialogue viewport clamp */
    --nyx-text-max: 118px;
    --nyx-text-max-open: 260px;

    /* Efficiency tuning */
    --nyx-chrome-scale: .86;
    --nyx-chrome-idle-opacity: .62;
    --nyx-chrome-hover-opacity: .94;

    --nyx-micropause-min: 420;
    --nyx-micropause-jitter: 340;

    --ease: cubic-bezier(.2,.8,.2,1);
  }

  /* ===== HERO STAGE (VIDEO-FIRST) ‚Äî HARD LOCKED ===== */
  #nyxStage{
    position:absolute;
    inset:0;
    background:#000;
    overflow:hidden;
    z-index:1;
  }

  #nyxHeroVideo{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:cover;
    object-position: var(--nyx-hero-pos-x) var(--nyx-hero-pos-y);
    transform: scale(var(--nyx-hero-scale-num));
    transform-origin: var(--nyx-hero-pos-x) var(--nyx-hero-pos-y);
    filter:saturate(1.04) contrast(1.02);
    pointer-events:none;
  }

  #nyxStage.is-image{
    background-repeat:no-repeat;
    background-size: 132% auto;
    background-position: var(--nyx-hero-pos-x) var(--nyx-hero-pos-y);
  }
  #nyxStage.is-image #nyxHeroVideo{ display:none; }

  #nyxStage::after{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    opacity:var(--nyx-hero-dim);
    background:
      radial-gradient(120% 100% at 52% 34%, rgba(0,0,0,0) 58%, rgba(0,0,0,.48) 100%),
      linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,.28));
    z-index:2;
  }

  @keyframes nyxPulse{
    0%{filter:brightness(1) saturate(1);}
    50%{filter:brightness(1.08) saturate(1.06);}
    100%{filter:brightness(1) saturate(1);}
  }
  html.nyx-thinking #nyxStage{ animation: nyxPulse .55s ease-in-out 1; }

  /* ===== Overlay layout ===== */
  #nyxOverlay{
    position:absolute;
    inset:0;
    display:flex;
    flex-direction:column;
    justify-content:flex-end;
    align-items:flex-end;
    padding:16px;
    pointer-events:none;
    z-index:10;
  }
  #nyxCard, #nyxCard * { pointer-events:auto; }

  /* ===== Docked Card ===== */
  #nyxCard{
    width:var(--nyx-card-w);
    border-radius:var(--nyx-card-radius);
    border:1px solid rgba(255,255,255,.11);
    background:
      radial-gradient(120% 160% at 50% 0%, rgba(255,255,255,.05) 0%, rgba(255,255,255,0) 46%),
      linear-gradient(145deg, var(--nyx-glass-1), var(--nyx-glass-2));
    box-shadow:0 26px 90px rgba(0,0,0,.78);
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);

    padding:var(--nyx-card-pad);
    margin-bottom: var(--nyx-card-bottom);
    max-height: var(--nyx-card-max);
    overflow:hidden;

    display:flex;
    flex-direction:column;
  }

  .nyx-head{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:10px;
  }

  .nyx-title{
    font: 650 14px var(--nyx-font);
    letter-spacing:.25px;
    color: rgba(255,255,255,.92);
    display:flex;
    align-items:center;
    gap:10px;
    user-select:none;
  }

  .nyx-dot{
    width:9px;height:9px;border-radius:999px;
    background: var(--nyx-accent);
    box-shadow: 0 0 14px rgba(140,0,35,.45);
  }

  .nyx-marion{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:18px;height:18px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
    color: rgba(255,255,255,.72);
    font: 700 11px var(--nyx-font);
    letter-spacing: .2px;
    transform: translateY(-.5px);
  }
  .nyx-marion.on{
    background: rgba(140,0,35,.16);
    border-color: rgba(140,0,35,.55);
    color: rgba(255,255,255,.90);
    box-shadow: 0 0 16px rgba(140,0,35,.25);
  }

  .nyx-head-right{
    display:flex;
    gap:8px;
    align-items:center;
    transform: scale(var(--nyx-chrome-scale));
    transform-origin: top right;
    opacity: var(--nyx-chrome-idle-opacity);
    transition: opacity .18s var(--ease);
  }
  .nyx-head-right:hover{ opacity: var(--nyx-chrome-hover-opacity); }

  .nyx-btn{
    font: 12px var(--nyx-font);
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
    color: rgba(255,255,255,.88);
    cursor:pointer;
    user-select:none;
    transition: filter .16s var(--ease), background .16s var(--ease), border-color .16s var(--ease), transform .16s var(--ease);
    white-space:nowrap;
  }
  .nyx-btn:hover{
    filter: brightness(1.08);
    border-color: rgba(255,255,255,.18);
    transform: translateY(-1px);
  }
  .nyx-btn.is-on{
    background: rgba(255,255,255,.08);
    border-color: rgba(255,255,255,.22);
  }

  /* ===== Debug surfaces (DOUBLE-GATED) ===== */
  #nyxCogBadge{
    margin: 0 0 10px 0;
    padding:8px 12px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(12,12,18,.74);
    color: rgba(255,255,255,.82);
    font:12px ui-monospace, Menlo, Consolas, monospace;
    letter-spacing:.2px;
    box-shadow:0 14px 40px rgba(0,0,0,.45);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    user-select:none;
    display:none;
  }

  #nyxDiag{
    margin-top:10px;
    font:12px ui-monospace, Menlo, Consolas, monospace;
    color: rgba(255,255,255,.55);
    user-select:none;
    display:none;
  }

  html.nyx-debug #nyxDiag{ display:block; }
  html.nyx-debug #nyxCogBadge{ display:inline-flex; }

  /* ===== Scroll region ===== */
  #nyxScroll{
    flex: 1 1 auto;
    min-height: 0;
    overflow:auto;
    padding-right: 4px;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,.18) rgba(0,0,0,0);
  }

  /* ===== Dialogue: clamped shows last assistant line only ===== */
  #nyxText{
    color: rgba(255,255,255,.96);
    font: 500 15.2px var(--nyx-font);
    line-height: 1.55;
    letter-spacing: .15px;
    white-space: pre-wrap;
    max-height: var(--nyx-text-max);
    overflow:auto;
    padding-right:6px;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,.18) rgba(0,0,0,0);
  }

  #nyxCard.is-clamped #nyxText{
    mask-image: linear-gradient(180deg, #000 78%, rgba(0,0,0,0));
    -webkit-mask-image: linear-gradient(180deg, #000 78%, rgba(0,0,0,0));
  }
  #nyxCard.is-open #nyxText{
    max-height: var(--nyx-text-max-open);
    mask-image:none;
    -webkit-mask-image:none;
  }

  .nyx-divider{
    height:1px;
    background: rgba(255,255,255,.06);
    margin:12px 0 12px 0;
  }

  /* ===== Transcript (EXPAND-ONLY) ===== */
  #nyxThread{
    display:none;
    margin: 8px 0 10px 0;
    gap:8px;
    flex-direction:column;
  }
  #nyxCard.is-open #nyxThread{ display:flex; }

  .nyx-msg{
    display:flex;
    gap:8px;
    align-items:flex-start;
  }
  .nyx-msg .who{
    flex:0 0 auto;
    width:28px;height:28px;
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    font: 750 12px var(--nyx-font);
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    color: rgba(255,255,255,.86);
  }
  .nyx-msg.user .who{
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.92);
  }
  .nyx-msg.nyx .who{
    background: rgba(140,0,35,.18);
    border-color: rgba(140,0,35,.45);
  }
  .nyx-msg .bubble{
    flex:1 1 auto;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.26);
    padding:10px 12px;
    color: rgba(255,255,255,.94);
    font: 500 13.6px var(--nyx-font);
    line-height: 1.45;
    white-space: pre-wrap;
  }
  .nyx-msg.user .bubble{
    background: rgba(255,255,255,.06);
    border-color: rgba(255,255,255,.12);
  }

  /* ===== Chips rail ‚Äî NOW WRAPS CLEANLY (no cut-off) ===== */
  .nyx-rail{ position:relative; }
  #nyxChips{
    display:flex;
    flex-wrap:wrap;          /* CRITICAL: fit all chips */
    gap:8px;
    overflow:hidden;         /* no ‚Äúsmidgen‚Äù peeking */
    padding: 2px 0 2px 0;
    transition: opacity .22s var(--ease), transform .22s var(--ease), filter .22s var(--ease);
    will-change: opacity, transform, filter;
  }

  html.nyx-chips-hidden #nyxChips{
    opacity:0;
    transform: translateY(6px);
    pointer-events:none;
    filter: blur(1.5px);
  }
  html.nyx-chips-shown #nyxChips{
    opacity:1;
    transform: translateY(0);
    pointer-events:auto;
    filter:none;
  }

  .action-pill{
    flex:0 0 auto;
    font: 12.2px var(--nyx-font);
    padding:8px 11px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.90);
    cursor:pointer;
    user-select:none;
    transition:
      transform .14s var(--ease),
      background .16s var(--ease),
      border-color .16s var(--ease),
      box-shadow .16s var(--ease);
    text-decoration:none;
    white-space:nowrap;
  }
  .action-pill:hover{
    transform: translateY(-1px);
    background: var(--nyx-accent-soft);
    border-color: rgba(140,0,35,.55);
    box-shadow: 0 12px 28px rgba(0,0,0,.35);
  }
  .action-pill.is-active{
    border-color: rgba(140,0,35,.60);
    background: rgba(140,0,35,.22);
  }

  /* ===== Roku link row (shown only on Roku lane) ===== */
  #nyxLinks{
    display:none;
    gap:10px;
    margin-top:10px;
  }
  #nyxLinks.show{ display:flex; }
  .nyx-link{
    flex:0 0 auto;
    font: 12px var(--nyx-font);
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
    color: rgba(255,255,255,.88);
    cursor:pointer;
    user-select:none;
    transition: filter .16s var(--ease), border-color .16s var(--ease), transform .16s var(--ease);
    white-space:nowrap;
  }
  .nyx-link:hover{
    filter: brightness(1.08);
    border-color: rgba(255,255,255,.18);
    transform: translateY(-1px);
  }

  /* ===== Input row ===== */
  .nyx-row{
    display:flex;
    gap:10px;
    margin-top:12px;
  }
  #nyxInput{
    flex:1;
    min-width: 0;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.42);
    color: rgba(255,255,255,.94);
    padding:12px 14px;
    outline:none;
    font: 14px var(--nyx-font);
  }
  #nyxInput::placeholder{ color: rgba(255,255,255,.50); }

  #nyxSend{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.92);
    padding:12px 16px;
    cursor:pointer;
    font: 650 13px var(--nyx-font);
    transition: background .16s var(--ease), border-color .16s var(--ease), filter .16s var(--ease);
    white-space:nowrap;
  }
  #nyxSend:hover{
    background: rgba(140,0,35,.18);
    border-color: rgba(255,255,255,.20);
    filter: brightness(1.04);
  }
  #nyxSend:disabled{
    opacity:.65;
    cursor:not-allowed;
    filter:none;
  }

  button:focus, input:focus{
    outline: none;
    box-shadow: 0 0 0 3px rgba(140,0,35,.25);
    border-color: rgba(140,0,35,.55) !important;
  }

  @media (max-width:520px){
    #nyxOverlay{ align-items:center; padding:12px; }
    :root{
      --nyx-card-w: min(460px, calc(100vw - 20px));
      --nyx-card-max: clamp(320px, 58vh, 480px);
      --nyx-text-max: 110px;
      --nyx-text-max-open: 240px;
      --nyx-hero-pos-y: 20%;
      --nyx-hero-scale-num: 1.20;
    }
    .action-pill{ font-size:12px; padding:8px 10px; }
  }

  @media (prefers-reduced-motion: reduce){
    .action-pill{ transition:none; }
    .nyx-btn{ transition:none; }
    html.nyx-thinking #nyxStage{ animation:none; }
  }


  /* ============================================================
     SMART CHIPS (Marion followUps)
     - separate rail, can wrap to 2 rows, but height-capped
     - visually consistent with existing action pills
  ============================================================ */
  #nyxSmartChips{
    margin-top:8px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    max-height:84px;
    overflow:auto;
    padding:2px 2px 0 2px;
    scrollbar-width: thin;
  }
  #nyxSmartChips::-webkit-scrollbar{ height:8px; width:8px; }
  #nyxSmartChips::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.12); border-radius: 999px; }

  .action-pill.smart{
    border-color: rgba(140,0,35,.28);
    background: rgba(140,0,35,.10);
  }
  .action-pill.smart:hover{
    filter: brightness(1.08);
  }
</style>
</head>

<body>
  <div id="nyxStage" aria-hidden="true">
    <video id="nyxHeroVideo" autoplay muted loop playsinline preload="auto"></video>
  </div>

  <div id="nyxOverlay">
    <div id="nyxCard" class="is-clamped" role="region" aria-label="Nyx Assistant">
      <div class="nyx-head">
        <div class="nyx-title">
          <span class="nyx-dot" aria-hidden="true"></span>
          <span>Nyx</span>
          <span id="nyxMarion" class="nyx-marion" title="Marion guiding" aria-label="Marion guiding">M</span>
        </div>

        <div class="nyx-head-right">
          <button class="nyx-btn" id="nyxMic" type="button" aria-label="Mic" title="Mic">üéôÔ∏è</button>
          <button class="nyx-btn" id="nyxVoiceToggle" type="button" aria-label="Voice" title="Voice">üîä Voice</button>
          <button class="nyx-btn" id="nyxExpand" type="button" aria-label="Expand" title="Expand">Expand</button>
        </div>
      </div>

      <div id="nyxCogBadge" aria-live="polite"></div>

      <div id="nyxScroll">
        <!-- EXPAND-ONLY transcript -->
        <div id="nyxThread" aria-label="Conversation transcript"></div>

        <!-- Always present: last Nyx output (sleek mode) -->
        <div id="nyxText" aria-live="polite">Hi‚Ä¶ I‚Äôm Nyx. How are you today?</div>

        <div class="nyx-divider"></div>

        <div class="nyx-rail">
          <div id="nyxChips" aria-label="Nyx modes">
            <div class="action-pill is-active" data-chip="general">General</div>
            <div class="action-pill" data-chip="music">Music</div>
            <div class="action-pill" data-chip="roku">Roku</div>
            <div class="action-pill" data-chip="movies">Movies</div>
            <div class="action-pill" data-chip="schedule">Schedule‚Üó</div>
            <div class="action-pill" data-chip="radio">Radio</div>
            <!-- News Canada removed for now to keep chips clean and fully visible -->
          </div>

          <!-- SMART CHIPS (from Marion/chatEngine followUps) -->
          <div class="chips smart" id="nyxSmartChips" aria-label="Suggestions" style="display:none"></div>
        </div>

        <!-- Roku lane links (clean + not chip-crowding) -->
        <div id="nyxLinks" aria-label="Roku links">
          <button class="nyx-link" id="nyxLinkRoku" type="button">Open Roku</button>
          <button class="nyx-link" id="nyxLinkSBTV" type="button">Sandblast TV</button>
        </div>

        <div class="nyx-row">
          <input id="nyxInput" type="text" placeholder="Type a message‚Ä¶" autocomplete="off" />
          <button id="nyxSend" type="button">Send</button>
        </div>

        <div id="nyxDiag">HOST v9117l ‚Ä¢ ready</div>
      </div>
    </div>
  </div>

<script>
(function(){
  "use strict";

  // ==========
  // Utilities
  // ==========
  function $(id){ return document.getElementById(id); }
  function safeStr(x){ return (x===null || x===undefined) ? "" : String(x); }
  function safeJsonParse(str){ try { return JSON.parse(str); } catch(e){ return null; } }
  function now(){ return Date.now(); }
  function makeId(){
    try{ if(window.crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(_){}
    return (Math.random().toString(16).slice(2) + now().toString(16)).slice(0, 24);
  }
  function clampToken(s, minLen){
    s = safeStr(s).trim();
    if(!s) return "";
    if(minLen && s.length < minLen) return "";
    if(s.length > 256) s = s.slice(0,256);
    return s;
  }
  function escapeRegExp(s){
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function sha1Lite(str){
    var s = safeStr(str);
    var h = 2166136261;
    for (var i = 0; i < s.length; i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(16);
  }
  function safeCssUrl(raw){
    var s = safeStr(raw).trim();
    if(!s) return "";
    if(!/^https?:\/\//i.test(s)) return "";
    s = s.replace(/[\r\n\t]/g, "");
    return s;
  }
  function isMp4Url(u){
    u = safeStr(u).toLowerCase();
    return (u.indexOf(".mp4") > -1) || (u.indexOf("video/mp4") > -1);
  }
  function parseScaleToNumber(v){
    var s = safeStr(v).trim();
    if(!s) return 1.0;
    if(s.indexOf("%") > -1){
      var n = parseFloat(s.replace("%",""));
      if(isFinite(n) && n > 0) return n / 100;
      return 1.0;
    }
    var f = parseFloat(s);
    if(isFinite(f) && f > 0) return f;
    return 1.0;
  }

  // ==========
  // Elements
  // ==========
  var diagEl = $("nyxDiag");
  var cardEl = $("nyxCard");
  var textEl = $("nyxText");
  var threadEl = $("nyxThread");
  var expandBtn = $("nyxExpand");
  var chipsEl = $("nyxChips");
  var smartChipsEl = $("nyxSmartChips");
  var inputEl = $("nyxInput");
  var sendBtn = $("nyxSend");
  var micBtn = $("nyxMic");
  var voiceBtn = $("nyxVoiceToggle");
  var cogEl = $("nyxCogBadge");
  var marionEl = $("nyxMarion");
  var linksWrap = $("nyxLinks");
  var linkRoku = $("nyxLinkRoku");
  var linkSBTV = $("nyxLinkSBTV");

  var stageEl = $("nyxStage");
  var heroVid = $("nyxHeroVideo");

  function diag(msg){ if(diagEl) diagEl.textContent = msg; }

  // ==========
  // Efficiency states
  // ==========
  function setChipsHidden(){
    document.documentElement.classList.add("nyx-chips-hidden");
    document.documentElement.classList.remove("nyx-chips-shown");
  }
  function setChipsShown(){
    document.documentElement.classList.add("nyx-chips-shown");
    document.documentElement.classList.remove("nyx-chips-hidden");
  }
  function thinkingOn(){ document.documentElement.classList.add("nyx-thinking"); }
  function thinkingOff(){ document.documentElement.classList.remove("nyx-thinking"); }
  function microPause(){
    var cs = getComputedStyle(document.documentElement);
    var min = parseInt(cs.getPropertyValue("--nyx-micropause-min"), 10);
    var jit = parseInt(cs.getPropertyValue("--nyx-micropause-jitter"), 10);
    if(!isFinite(min)) min = 420;
    if(!isFinite(jit)) jit = 340;
    var ms = min + Math.floor(Math.random() * Math.max(0, jit));
    return new Promise(function(res){ setTimeout(res, ms); });
  }

  // Hide chips until first real assistant reply
  var HAS_ASSISTANT_SPOKEN = false;
  setChipsHidden();

  // ==========
  // Config / Debug gate (DOUBLE-GATED)
  // ==========
  var PARENT_ORIGIN = null;
  var READY_ACK = false;
  var CONFIG_ONCE_HASH = "";

  function urlHasDebug(){
    try{
      return /(?:\?|&)debug=1(?:&|$)/i.test(location.search || "");
    }catch(_){ return false; }
  }

  var CONFIG = {
    version: "9117i",
    apiBase: null,
    token: null,
    heroSrc: null,
    voiceDefaultOn: false,
    publicMode: true,
    forbiddenNames: ["Mac"],
    debug: false,

    // optional nav urls (parent may override)
    nav: {
      roku: "https://www.roku.com/",
      sandblastTV: "https://sandblast.channel/"
    }
  };

  function applyDebugGate(){
    // DOUBLE-GATE: must be URL ?debug=1 AND config.debug true
    var allow = !!CONFIG.debug && urlHasDebug();
    document.documentElement.classList.toggle("nyx-debug", allow);
    if(!allow && cogEl) cogEl.style.display = "none";
    if(!allow && diagEl) diagEl.style.display = "none";
  }

  // ==========
  // Public text sanitizer
  // ==========
  function sanitizeReplyText(t){
    var s = safeStr(t || "");
    if(!CONFIG.publicMode) return s;

    var names = Array.isArray(CONFIG.forbiddenNames) ? CONFIG.forbiddenNames.slice(0) : [];
    if(names.indexOf("Mac") === -1) names.push("Mac");

    for(var i=0;i<names.length;i++){
      var n = safeStr(names[i]).trim();
      if(!n) continue;
      try{
        var rx = new RegExp("\\b" + escapeRegExp(n) + "\\b", "gi");
        s = s.replace(rx, "friend");
      }catch(_){}
    }

    s = s
      .replace(/\bfriend\b\s*([,.;:!?])/gi, "$1")
      .replace(/\(\s*friend\s*\)/gi, "")
      .replace(/\s{2,}/g, " ")
      .replace(/\n{3,}/g, "\n\n")
      .trim();

    s = s.replace(/^(alright|okay|hey)\s*,\s*friend\b\.?/i, "$1.").trim();
    return s;
  }

  function setText(t){
    if(!textEl) return;
    textEl.textContent = sanitizeReplyText(t || "");
    try{ textEl.scrollTop = 0; }catch(_){}
  }

  // ==========
  // Marion indicator
  // ==========
  function setMarionOn(on){
    if(!marionEl) return;
    marionEl.classList.toggle("on", !!on);
  }

  // ==========
  // Debug badge renderer (only when debug gate passes)
  // ==========
  function renderCogBadge(data){
    if(!cogEl) return;
    if(!(document.documentElement.classList.contains("nyx-debug"))){
      cogEl.style.display = "none";
      return;
    }

    var lane = (data && typeof data.lane === "string") ? data.lane : "";
    var cog = (data && data.cog && typeof data.cog === "object") ? data.cog : null;

    var parts = [];
    if(lane) parts.push("lane:" + safeStr(lane));
    if(cog){
      if(cog.mode) parts.push("mode:" + safeStr(cog.mode));
      if(cog.intent) parts.push("intent:" + safeStr(cog.intent));
      if(cog.nextMoveStage) parts.push("stage:" + safeStr(cog.nextMoveStage));
      if(cog.budget) parts.push("budget:" + safeStr(cog.budget));
      if(cog.dominance !== undefined && cog.dominance !== null) parts.push("dom:" + safeStr(cog.dominance));
      if(Array.isArray(cog.tags) && cog.tags.length){
        parts.push("tags:" + cog.tags.slice(0,3).map(function(x){ return safeStr(x); }).join(","));
      }
      if(cog.marionTraceHash) parts.push("m:" + safeStr(cog.marionTraceHash).slice(0,10));
    }else{
      parts.push("cog:missing");
    }

    var line = parts.join(" ‚Ä¢ ");
    if(!line) line = "bridge:unknown";

    cogEl.textContent = line;
    cogEl.style.display = "inline-flex";
  }

  // ==========
  // Hero stage wiring (HARDENED)
  // ==========
  function setStageImage(url){
    if(!stageEl) return;
    var u = safeCssUrl(url);
    if(!u) return;
    stageEl.style.backgroundImage = 'url("' + u + '")';
  }

  function setStageImageFallback(on){
    if(!stageEl) return;
    stageEl.classList.toggle("is-image", !!on);
  }

  function setHeroVideoSrc(url){
    if(!heroVid) return false;
    var u = safeCssUrl(url);
    if(!u) return false;

    try{
      heroVid.pause();
      heroVid.removeAttribute("src");
      while(heroVid.firstChild) heroVid.removeChild(heroVid.firstChild);
    }catch(_){}

    var source = document.createElement("source");
    source.src = u;
    source.type = "video/mp4";
    heroVid.appendChild(source);

    try{ heroVid.load(); }catch(_){}
    try{
      var p = heroVid.play();
      if(p && typeof p.catch === "function"){ p.catch(function(){}); }
    }catch(_){}

    return true;
  }

  function setHeroImageSrc(url){
    var u = safeCssUrl(url);
    if(!u) return false;
    try{ if(heroVid) heroVid.setAttribute("poster", u); }catch(_){}
    setStageImage(u);
    return true;
  }

  (function bootHeroDefaults(){
    try{
      var rawImg = getComputedStyle(document.documentElement).getPropertyValue("--nyx-hero-img-url");
      rawImg = rawImg.replace(/["']/g,"").trim();
      if(rawImg) setHeroImageSrc(rawImg);
    }catch(_){}

    try{
      var rawVid = getComputedStyle(document.documentElement).getPropertyValue("--nyx-hero-video");
      rawVid = rawVid.replace(/["']/g,"").trim();
      if(rawVid){
        var ok = setHeroVideoSrc(rawVid);
        if(!ok) setStageImageFallback(true);
      }else{
        setStageImageFallback(true);
      }
    }catch(_){
      setStageImageFallback(true);
    }
  })();

  if(heroVid){
    heroVid.muted = true;
    heroVid.loop = true;
    heroVid.playsInline = true;
    heroVid.setAttribute("playsinline", "playsinline");
    heroVid.setAttribute("muted", "muted");
    heroVid.setAttribute("autoplay", "autoplay");

    var autoplayGuard = setTimeout(function(){
      try{
        if(heroVid.readyState < 2){
          setStageImageFallback(true);
          diag("HOST v9117l ‚Ä¢ autoplay blocked (fallback)");
        }
      }catch(_){}
    }, 900);

    heroVid.addEventListener("error", function(){
      setStageImageFallback(true);
      diag("HOST v9117l ‚Ä¢ video error (fallback)");
    });

    heroVid.addEventListener("loadeddata", function(){
      try{ clearTimeout(autoplayGuard); }catch(_){}
      setStageImageFallback(false);
    });
  }

  // ==========
  // postMessage bridge (hardened)
  // ==========
  function postToParent(payload, allowWildcard){
    if(!window.parent || window.parent === window) return false;
    try{
      var target = PARENT_ORIGIN || (allowWildcard ? "*" : null);
      if(!target) return false;

      var out = payload;
      if(payload && typeof payload === "object"){
        out = Object.assign({}, payload);
        if(out.token) out.token = "[redacted]";
        if(out.packet && typeof out.packet === "object"){
          var pkt = Object.assign({}, out.packet);
          if(pkt.__token) pkt.__token = "[redacted]";
          if(pkt.token) pkt.token = "[redacted]";
          out.packet = pkt;
        }
      }

      window.parent.postMessage(out, target);
      return true;
    }catch(e){ return false; }
  }

  function sendReady(){
    postToParent({ type:"NYX_READY", v:CONFIG.version, ts: now() }, true);
  }

  var tries = 0;
  var maxTries = 14;
  var readyTimer = setInterval(function(){
    tries++;
    if(READY_ACK || tries > maxTries){
      clearInterval(readyTimer);
      return;
    }
    sendReady();
  }, 250);
  sendReady();

  // ==========
  // Inbound messages (origin lock)
  // ==========
  var ORIGIN_LEARN_TYPES = {
    "NYX_READY_ACK": true,
    "NYX_CONFIG": true,
    "NYX_CAL": true,
    "NYX_PING": true,
    "NYX_SET_BUBBLE": true
  };

  window.addEventListener("message", function(ev){
    try{
      if(!ev) return;

      var data = ev.data;
      if(typeof data === "string"){
        var parsed = safeJsonParse(data);
        if(parsed) data = parsed;
      }
      if(!data || typeof data !== "object") return;

      var t = data.type;
      if(typeof t !== "string" || t.indexOf("NYX_") !== 0) return;

      if(!PARENT_ORIGIN && ORIGIN_LEARN_TYPES[t] && typeof ev.origin === "string" && ev.origin){
        PARENT_ORIGIN = ev.origin;
        diag("HOST v9117l ‚Ä¢ origin locked");
      }

      if(PARENT_ORIGIN && ev.origin !== PARENT_ORIGIN) return;

      if(t === "NYX_READY_ACK"){
        READY_ACK = true;
        diag("HOST v9117l ‚Ä¢ ready (ack)");
        return;
      }

      if(t === "NYX_CONFIG"){
        var c = (data.config && typeof data.config === "object") ? data.config : {};

        var cfgSig = sha1Lite(JSON.stringify({
          apiBase: safeStr(c.apiBase||"").trim(),
          token: safeStr(c.token||"").trim(),
          heroSrc: safeStr(c.heroSrc||"").trim(),
          voiceDefaultOn: !!c.voiceDefaultOn,
          publicMode: (c.publicMode !== false),
          debug: !!c.debug,
          nav: c.nav || null
        })).slice(0,18);

        if(cfgSig && cfgSig === CONFIG_ONCE_HASH){
          postToParent({ type:"NYX_CONFIG_ACK", v: CONFIG.version, ts: now(), deduped:true }, false);
          diag("HOST v9117l ‚Ä¢ config deduped");
          return;
        }
        CONFIG_ONCE_HASH = cfgSig;

        if(typeof c.apiBase === "string") CONFIG.apiBase = safeStr(c.apiBase).trim();
        if(typeof c.token === "string") CONFIG.token = clampToken(c.token, 16);
        if(typeof c.heroSrc === "string") CONFIG.heroSrc = safeStr(c.heroSrc).trim();
        if(typeof c.voiceDefaultOn === "boolean") CONFIG.voiceDefaultOn = c.voiceDefaultOn;
        if(typeof c.publicMode === "boolean") CONFIG.publicMode = c.publicMode;
        if(Array.isArray(c.forbiddenNames)) CONFIG.forbiddenNames = c.forbiddenNames.slice(0, 12).map(function(x){ return safeStr(x).trim(); }).filter(Boolean);
        if(typeof c.debug === "boolean") CONFIG.debug = c.debug;

        if(c.nav && typeof c.nav === "object"){
          if(typeof c.nav.roku === "string") CONFIG.nav.roku = safeStr(c.nav.roku).trim();
          if(typeof c.nav.sandblastTV === "string") CONFIG.nav.sandblastTV = safeStr(c.nav.sandblastTV).trim();
        }

        applyDebugGate();

        if(CONFIG.heroSrc){
          var safeUrl = safeCssUrl(CONFIG.heroSrc);
          if(safeUrl){
            if(isMp4Url(safeUrl)){
              setStageImageFallback(false);
              setHeroVideoSrc(safeUrl);
            }else{
              setHeroImageSrc(safeUrl);
              setStageImageFallback(true);
            }
          }
        }

        if(CONFIG.voiceDefaultOn) setVoice(true);

        if(!CONFIG.token){
          postToParent({ type:"NYX_NEED_TOKEN", v: CONFIG.version, ts: now() }, false);
        }

        diag("HOST v9117l ‚Ä¢ config loaded");
        postToParent({ type:"NYX_CONFIG_ACK", v: CONFIG.version, ts: now() }, false);
        return;
      }

      if(t === "NYX_CAL" && data.cal && typeof data.cal === "object"){
        var cal = data.cal;
        if(typeof cal.heroPosX === "string") document.documentElement.style.setProperty("--nyx-hero-pos-x", cal.heroPosX);
        if(typeof cal.heroPosY === "string") document.documentElement.style.setProperty("--nyx-hero-pos-y", cal.heroPosY);

        if(typeof cal.heroScale === "string"){
          var n = parseScaleToNumber(cal.heroScale);
          document.documentElement.style.setProperty("--nyx-hero-scale-num", String(n));
        }
        if(typeof cal.cardMax === "string") document.documentElement.style.setProperty("--nyx-card-max", cal.cardMax);

        diag("HOST v9117l ‚Ä¢ cal applied");
        return;
      }

      if(t === "NYX_PING"){
        postToParent({ type:"NYX_PONG", v: CONFIG.version, ts: now() }, false);
        return;
      }

      if(t === "NYX_SET_BUBBLE" && typeof data.text === "string"){
        setText(data.text);
        if(!HAS_ASSISTANT_SPOKEN){ HAS_ASSISTANT_SPOKEN = true; setChipsShown(); }
        return;
      }

    }catch(_){}
  });

  // ==========
  // Backend client (hardened)
  // ==========
  function apiBase(){
    var b = (CONFIG.apiBase && String(CONFIG.apiBase).trim()) ? String(CONFIG.apiBase).trim() : location.origin;
    b = b.replace(/\/+$/,"");
    return b;
  }

  async function postJson(url, payload, timeoutMs){
    timeoutMs = timeoutMs || 12000;

    var headers = { "Content-Type":"application/json" };
    if(CONFIG.token){
      headers["Authorization"] = "Bearer " + CONFIG.token;
      headers["X-API-Token"] = CONFIG.token;
    }
    headers["X-Client-Source"] = "nyx_host_iframe";
    headers["X-Route-Hint"] = safeStr(payload && payload.client && payload.client.routeHint ? payload.client.routeHint : UI_STATE.lane);

    var ctrl = new AbortController();
    var to = setTimeout(function(){ try{ ctrl.abort(); }catch(_){} }, timeoutMs);

    try{
      var r = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify(payload),
        credentials: "include",
        signal: ctrl.signal
      });

      var txt = await r.text().catch(function(){ return ""; });
      var json = safeJsonParse(txt);

      if(!json){
        return { ok:false, error:"bad_json", status:r.status, raw: txt.slice(0, 600), __httpStatus: r.status };
      }
      json.__httpStatus = r.status;
      return json;

    } catch(e){
      var code = (e && e.name === "AbortError") ? "timeout" : "network";
      return { ok:false, error: code, status: 0, __httpStatus: 0 };
    } finally {
      clearTimeout(to);
    }
  }

  // ==========
  // UI State + Lane Hard-Lock
  // ==========
  var UI_STATE = {
    lane: "general",
    chip: "general",
    voiceOn: false,
    sttOn: false,
    pending: false,
    lastRequestId: null,
    laneHardLock: true,   // CRITICAL: never drift lanes visually

    __lastOutboundSig: "",
    __lastOutboundAt: 0,
    __lastReplySig: "",
    __lastReplyAt: 0
  };

  function laneFromChip(chip){
    chip = safeStr(chip).toLowerCase().trim();
    if(chip === "general") return "general";
    if(chip === "music") return "music";
    if(chip === "roku") return "roku";
    if(chip === "movies") return "movies";
    if(chip === "radio") return "radio";
    if(chip === "schedule") return "schedule";
    return "general";
  }

  // ==========
  // Transcript (expand-only)
  // ==========
  var THREAD = [];
  var MAX_TURNS = 14;

  function pushThread(role, text){
    var t = safeStr(text).trim();
    if(!t) return;
    THREAD.push({ role: role, text: t, ts: now() });
    if(THREAD.length > MAX_TURNS) THREAD = THREAD.slice(THREAD.length - MAX_TURNS);
  }

  function renderThread(){
    if(!threadEl) return;
    if(!(cardEl && cardEl.classList.contains("is-open"))){
      threadEl.innerHTML = "";
      return;
    }
    var html = "";
    for(var i=0;i<THREAD.length;i++){
      var m = THREAD[i];
      var who = (m.role === "user") ? "U" : "N";
      var cls = (m.role === "user") ? "nyx-msg user" : "nyx-msg nyx";
      html += '<div class="'+cls+'"><div class="who">'+who+'</div><div class="bubble"></div></div>';
    }
    threadEl.innerHTML = html;

    // fill text safely
    var rows = threadEl.querySelectorAll(".nyx-msg");
    for(var j=0;j<rows.length;j++){
      var bub = rows[j].querySelector(".bubble");
      if(bub) bub.textContent = THREAD[j].text;
    }
  }

  // ==========
  // Expand/Collapse
  // ==========
  var isExpanded = false;
  function applyClampUI(){
    if(!cardEl) return;
    cardEl.classList.toggle("is-open", isExpanded);
    cardEl.classList.toggle("is-clamped", !isExpanded);
    if(expandBtn) expandBtn.textContent = isExpanded ? "Collapse" : "Expand";
    renderThread();
  }
  if(expandBtn){
    expandBtn.addEventListener("click", function(){
      isExpanded = !isExpanded;
      applyClampUI();
    });
  }
  applyClampUI();

  // ==========
  // Chips + lane + Roku link row
  // ==========
  function updateRokuLinksVisibility(){
    if(!linksWrap) return;
    linksWrap.classList.toggle("show", UI_STATE.lane === "roku");
  }

  function setActiveChip(chip){
    UI_STATE.chip = chip;
    UI_STATE.lane = laneFromChip(chip);
    updateRokuLinksVisibility();

    if(chipsEl){
      var pills = chipsEl.querySelectorAll(".action-pill");
      for(var i=0;i<pills.length;i++){
        var p = pills[i];
        var c = p.getAttribute("data-chip");
        p.classList.toggle("is-active", c === chip);
      }
    }
  }

  function openLink(where){
    // Allow either a known key (help/support/privacy/schedule/docs) or a full URL.
    var key = safeStr(where, 160).trim();
    var url = "";
    if (/^https?:\/\//i.test(key)) url = key;
    else if (CONFIG.nav && CONFIG.nav[key]) url = CONFIG.nav[key];

    postToParent(
      { type:"NYX_NAV", where: key, url: url || undefined, lane: UI_STATE.lane, ts: now() },
      false
    );
  }

  
  // =========================
  // SMART CHIPS (from backend followUps)
  // - followUps: [{id,label,payload}]
  // - clicking a smart chip sends its payload (route/action/year/lane/etc)
  // - ALSO records a visible user-line so conversation is not disjointed
  // =========================
  var LAST_FOLLOWUPS = [];

  function normalizeFollowUps(fu){
    var arr = Array.isArray(fu) ? fu : [];
    var out = [];
    for(var i=0;i<arr.length && out.length<12;i++){
      var it = arr[i] || {};
      var id = safeStr(it.id || it._id || "", 80).trim();
      var label = safeStr(it.label || it.title || it.text || "", 120).trim();
      var payload = (it.payload && typeof it.payload === "object") ? it.payload : {};
      // Minimal payload normalization for stateSpine actionability
      var p = {};
      if(safeStr(payload.action)) p.action = safeStr(payload.action, 60);
      if(safeStr(payload.route)) p.route = safeStr(payload.route, 60);
      if(safeStr(payload.lane)) p.lane = safeStr(payload.lane, 24);
      if(Number.isFinite(Number(payload.year))) p.year = Number(payload.year);
      // Keep small identifiers
      if(safeStr(payload.id)) p.id = safeStr(payload.id, 80);
      if(safeStr(payload.label)) p.label = safeStr(payload.label, 120);
      // Always include chip id/label for UI + traces
      if(id) p.id = p.id || id;
      if(label) p.label = p.label || label;

      // If payload is empty but we do have an id/label, keep it so backend can interpret
      if(!Object.keys(p).length && (id || label)){
        if(id) p.id = id;
        if(label) p.label = label;
        p.action = "followup";
      }

      if(!label && id) label = id;
      if(!label) continue;

      out.push({ id: id || ("fu_" + i), label: label, payload: p });
    }
    return out;
  }

  function renderSmartChips(followUps){
    if(!smartChipsEl) return;
    LAST_FOLLOWUPS = normalizeFollowUps(followUps);

    if(!LAST_FOLLOWUPS.length){
      smartChipsEl.style.display = "none";
      smartChipsEl.innerHTML = "";
      return;
    }

    var html = "";
    for(var i=0;i<LAST_FOLLOWUPS.length;i++){
      var it = LAST_FOLLOWUPS[i];
      html += '<div class="action-pill smart" role="button" tabindex="0" data-fu="' + i + '">' +
              escapeHtml(it.label) +
              '</div>';
    }
    smartChipsEl.innerHTML = html;
    smartChipsEl.style.display = "flex";
  }

  function handleSmartChipClick(idx){
    var i = Number(idx);
    if(!Number.isFinite(i)) return;
    var it = LAST_FOLLOWUPS[i];
    if(!it) return;

    // Visible user intent line (prevents "ghost clicks" and broken conversational flow)
    pushThread("user", it.label);
    renderThread();

    // Use payload as the actionable packet; action param should agree with payload.action/route.
    var p = (it.payload && typeof it.payload === "object") ? it.payload : {};
    var act = safeStr(p.action || p.route || "followup", 60).trim();
    sendPacket("", act, p, { textEmpty:true, hasPayload:true, payloadActionable:true });
  }
function handleChipClick(chip){
    chip = safeStr(chip).trim();
    if(!chip) return;

    setActiveChip(chip);

    // external nav chip
    if(chip === "schedule"){
      openLink("schedule");
      return;
    }

    // internal lanes
    var packet = buildIntentPacket({
      text: "",
      chip: chip,
      lane: UI_STATE.lane,
      action: "chip",
      intent: "select",
      label: chip
    });

    postToParent({ type:"NYX_CHIP", v:CONFIG.version, ts:now(), chip: chip, lane: UI_STATE.lane }, false);
    return sendPacket(packet);
  }

  if(chipsEl){
    chipsEl.addEventListener("click", function(e){
      try{
        var t = e.target;
        while(t && t !== chipsEl && !(t.classList && t.classList.contains("action-pill"))){
          t = t.parentNode;
        }
        if(!t || t === chipsEl) return;
        var chip = t.getAttribute("data-chip");
        if(!chip) return;
        handleChipClick(chip);
      }catch(_){}
    });
  }

  if(linkRoku){
    linkRoku.addEventListener("click", function(){
      // parent should open the actual URL; host just requests navigation
      postToParent({ type:"NYX_NAV", where:"roku-site", url: CONFIG.nav.roku, ts: now() }, false);
    });
  }
  if(linkSBTV){
    linkSBTV.addEventListener("click", function(){
      postToParent({ type:"NYX_NAV", where:"sandblast-tv", url: CONFIG.nav.sandblastTV, ts: now() }, false);
    });
  }

  setActiveChip("general");

  // Smart chips: backend followUps
  if(smartChipsEl){
    smartChipsEl.addEventListener("click", function(ev){
      try{
        var t = ev.target;
        if(!t) return;
        var idx = t.getAttribute && t.getAttribute("data-fu");
        if(idx == null) return;
        handleSmartChipClick(idx);
      }catch(_){ }
    });

    smartChipsEl.addEventListener("keydown", function(ev){
      try{
        if(ev.key !== "Enter" && ev.key !== " ") return;
        var t = ev.target;
        if(!t) return;
        var idx = t.getAttribute && t.getAttribute("data-fu");
        if(idx == null) return;
        ev.preventDefault();
        handleSmartChipClick(idx);
      }catch(_){ }
    });
  }


  // ==========
  // Intent packet builder (lane hard-lock included)
  // ==========
  function buildCtxSnapshot(){
    // Small, bounded context to help the backend keep the conversation coherent.
    // NOTE: this is intentionally tiny; no HTML, capped lengths, last few turns only.
    var tail = THREAD.slice(-6).map(function(m){
      return { r: safeStr(m.role, 10), t: safeStr(m.text, 380), ts: Number(m.ts||0)||0 };
    });
    var ac = UI_STATE.activeChip ? {
      id: safeStr(UI_STATE.activeChip.id||"", 80),
      lane: safeStr(UI_STATE.lane||"", 24),
      route: safeStr(UI_STATE.activeChip.payload && (UI_STATE.activeChip.payload.route||UI_STATE.activeChip.payload.action)||"", 80),
      year: UI_STATE.activeChip.payload && UI_STATE.activeChip.payload.year ? Number(UI_STATE.activeChip.payload.year)||undefined : undefined
    } : null;
    return { threadTail: tail, active: ac || undefined };
  }

  function buildIntentPacket(opts){
    opts = (opts && typeof opts === "object") ? opts : {};

    var text = safeStr(opts.text).trim();
    var chip = safeStr(opts.chip || UI_STATE.chip || "general").trim();
    var lane = safeStr(opts.lane || UI_STATE.lane || "general").trim();
    var action = safeStr(opts.action || "").trim();
    var intent = safeStr(opts.intent || "").trim();
    var label = safeStr(opts.label || chip).trim();

    if(!text && !action){
      action = "chip";
      intent = intent || "select";
      label = label || chip;
    }

    var requestId = makeId();

    var payload = {
      lane: lane,
      chip: chip || undefined,
      action: action || undefined,
      intent: intent || undefined,
      label: label || undefined,

      // CRITICAL: tell backend we consider lane locked (it should respect this)
      laneHardLock: true
    };

    var turnSignals = {
      hasPayload: true,
      textEmpty: !text,
      payloadActionable: true,
      payloadLane: lane,
      payloadAction: action || "",
      payloadIntent: intent || "",
      payloadLabel: label || "",
      payloadChip: chip || ""
    };

    return {
      requestId: requestId,
      text: text,
      lane: lane,
      action: action,
      payload: payload,
      ctx: buildCtxSnapshot(),
      turnSignals: turnSignals,
      client: { source: "nyx_host_iframe", routeHint: lane, chip: chip }
    };
  }

  function setPending(on){
    UI_STATE.pending = !!on;
    if(sendBtn) sendBtn.disabled = UI_STATE.pending;
    if(inputEl) inputEl.disabled = UI_STATE.pending;
  }

  // ==========
  // Voice (intro unlock)
  // ==========
  var AUDIO_UNLOCKED = false;
  var INTRO_SPOKEN = false;
  var INTRO_TEXT = "Hi‚Ä¶ I‚Äôm Nyx. How are you today?";

  function setVoice(on){
    UI_STATE.voiceOn = !!on;
    if(voiceBtn) voiceBtn.classList.toggle("is-on", UI_STATE.voiceOn);
  }

  function stopAudio(){
    try{
      if(window.__NYX_AUDIO && typeof window.__NYX_AUDIO.pause === "function"){
        window.__NYX_AUDIO.pause();
        window.__NYX_AUDIO.currentTime = 0;
      }
    }catch(_){}
  }

  async function speak(text){
    if(!UI_STATE.voiceOn) return;
    var s = safeStr(text).trim();
    if(!s) return;
    if(!AUDIO_UNLOCKED) return; // browser gesture policy

    stopAudio();

    try{
      var url = apiBase() + "/api/tts";
      var headers = { "Content-Type":"application/json" };
      if(CONFIG.token){
        headers["Authorization"] = "Bearer " + CONFIG.token;
        headers["X-API-Token"] = CONFIG.token;
      }

      var ctrl = new AbortController();
      var to = setTimeout(function(){ try{ ctrl.abort(); }catch(_){} }, 12000);

      var r = await fetch(url, {
        method: "POST",
        headers: headers,
        body: JSON.stringify({ text: s }),
        credentials: "include",
        signal: ctrl.signal
      }).catch(function(){ return null; });

      clearTimeout(to);
      if(!r || !r.ok) return;

      var buf = await r.arrayBuffer();
      var blob = new Blob([buf], { type: "audio/mpeg" });
      var objUrl = URL.createObjectURL(blob);

      var a = new Audio(objUrl);
      window.__NYX_AUDIO = a;
      a.onended = function(){ try{ URL.revokeObjectURL(objUrl); }catch(_){ } };
      a.play().catch(function(){});
    }catch(_){}
  }

  function unlockAudioAndMaybeIntro(){
    if(AUDIO_UNLOCKED) return;
    AUDIO_UNLOCKED = true;

    // If voice is ON, speak the intro once right after first interaction
    if(UI_STATE.voiceOn && !INTRO_SPOKEN){
      INTRO_SPOKEN = true;
      speak(INTRO_TEXT);
    }
  }

  // Any interaction in card unlocks audio for later TTS
  if(cardEl){
    cardEl.addEventListener("pointerdown", unlockAudioAndMaybeIntro, { passive:true });
    cardEl.addEventListener("keydown", unlockAudioAndMaybeIntro, { passive:true });
  }

  if(voiceBtn){
    voiceBtn.addEventListener("click", function(){
      setVoice(!UI_STATE.voiceOn);
      if(!UI_STATE.voiceOn) stopAudio();
      postToParent({ type:"NYX_VOICE_TOGGLE", v:CONFIG.version, ts:now(), on: UI_STATE.voiceOn }, false);

      // If turning ON after interaction, speak intro once (nice touch)
      if(UI_STATE.voiceOn && AUDIO_UNLOCKED && !INTRO_SPOKEN){
        INTRO_SPOKEN = true;
        speak(INTRO_TEXT);
      }
    });
  }

  // ==========
  // STT
  // ==========
  var SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;
  var rec = null;

  function setMic(on){
    UI_STATE.sttOn = !!on;
    if(micBtn) micBtn.classList.toggle("is-on", UI_STATE.sttOn);
  }

  function stopSTT(){
    try{
      if(rec){
        rec.onresult = null; rec.onerror = null; rec.onend = null;
        rec.stop();
      }
    }catch(_){}
    setMic(false);
  }

  function startSTT(){
    if(!SpeechRecognition){ diag("HOST v9117l ‚Ä¢ STT unsupported"); return; }
    if(UI_STATE.pending) return;

    if(!rec){
      rec = new SpeechRecognition();
      rec.continuous = false;
      rec.interimResults = false;
      rec.lang = "en-US";
    }

    rec.onresult = function(ev){
      try{
        var t = "";
        if(ev && ev.results && ev.results[0] && ev.results[0][0]){
          t = safeStr(ev.results[0][0].transcript).trim();
        }
        if(t){
          if(inputEl) inputEl.value = t;
          sendTypedText();
        }
      }catch(_){}
    };

    rec.onerror = function(){ stopSTT(); diag("HOST v9117l ‚Ä¢ STT error"); };
    rec.onend = function(){ setMic(false); };

    try{ rec.start(); setMic(true); diag("HOST v9117l ‚Ä¢ listening‚Ä¶"); }catch(_){ setMic(false); }
  }

  if(micBtn){
    micBtn.addEventListener("click", function(){
      if(UI_STATE.sttOn) stopSTT(); else startSTT();
      postToParent({ type:"NYX_MIC_TOGGLE", v:CONFIG.version, ts:now(), on: UI_STATE.sttOn }, false);
    });
  }

  // ==========
  // Send pipeline (loop guards + Marion indicator + micro-pause)
  // ==========
  function sanitizeCog(cog){
    if(!cog || typeof cog !== "object") return null;
    var out = {};
    if(cog.mode) out.mode = safeStr(cog.mode);
    if(cog.intent) out.intent = safeStr(cog.intent);
    if(cog.nextMoveStage) out.nextMoveStage = safeStr(cog.nextMoveStage);
    if(cog.budget) out.budget = safeStr(cog.budget);
    if(cog.dominance !== undefined && cog.dominance !== null) out.dominance = cog.dominance;
    if(Array.isArray(cog.tags)) out.tags = cog.tags.slice(0,5).map(function(x){ return safeStr(x); });
    if(cog.marionTraceHash) out.marionTraceHash = safeStr(cog.marionTraceHash);
    return out;
  }

  function marionPresent(out){
    // Detect Marion cognition bridge across multiple response shapes (fail-open).
    if(!out || typeof out!=="object") return false;

    // Preferred: out.marion (sanitized MarionSO) OR out.state.marion
    if(out.marion && typeof out.marion === "object") return true;
    if(out.state && out.state.marion && typeof out.state.marion === "object") return true;

    // Alternate: out.cog.traceBits / out.cog.marionTraceHash (older contract)
    var c = out.cog && typeof out.cog === "object" ? out.cog : null;
    if(c){
      if(c.marionTraceHash) return true;
      if(c.traceBits && typeof c.traceBits === "object" && Object.keys(c.traceBits).length) return true;
      if(c.trace && typeof c.trace === "object" && Object.keys(c.trace).length) return true;
    }

    // Telemetry variants
    var t = out.meta && out.meta.telemetry ? out.meta.telemetry : null;
    if(t){
      if(t.marionTraceHash) return true;
      if(t.marion && typeof t.marion === "object"){
        if(t.marion.traceHash) return true;
        if(t.marion.bits && typeof t.marion.bits === "object" && Object.keys(t.marion.bits).length) return true;
      }
    }
    return false;
  }

  function outboundSig(packet){
    var keyObj = {
      t: safeStr(packet && packet.text || ""),
      lane: safeStr(packet && packet.lane || ""),
      action: safeStr(packet && packet.action || ""),
      chip: safeStr(packet && packet.client && packet.client.chip || ""),
      p: packet && packet.payload ? Object.keys(packet.payload).sort().join(",") : ""
    };
    return sha1Lite(JSON.stringify(keyObj)).slice(0, 18);
  }

  function replySig(out, fallbackLane){
    var rid = safeStr(out && (out.requestId || (out.meta && out.meta.requestId)) || "");
    if(rid) return "rid:" + rid;
    var r = safeStr(out && out.reply || "");
    var lane = safeStr(out && out.lane || fallbackLane || "");
    return "sig:" + sha1Lite(lane + "|" + r.slice(0,220)).slice(0, 18);
  }

  async function renderAssistantReply(text){
    thinkingOn();
    await microPause();
    thinkingOff();

    setText(text);
    pushThread("nyx", text);
    renderThread();

    if(!HAS_ASSISTANT_SPOKEN){
      HAS_ASSISTANT_SPOKEN = true;
      setChipsShown();
    }
  }

  async function sendPacket(packet){
    if(UI_STATE.pending) return;

    var sig = outboundSig(packet);
    var t = now();
    if(sig && UI_STATE.__lastOutboundSig === sig && (t - UI_STATE.__lastOutboundAt) < 1200){
      diag("HOST v9117l ‚Ä¢ deduped outbound");
      return;
    }
    UI_STATE.__lastOutboundSig = sig;
    UI_STATE.__lastOutboundAt = t;

    UI_STATE.lastRequestId = safeStr(packet && packet.requestId);
    setPending(true);
    diag("HOST v9117l ‚Ä¢ sending‚Ä¶");

    postToParent({
      type:"NYX_OUTBOUND",
      v:CONFIG.version,
      ts:now(),
      packet: { requestId: packet.requestId, lane: packet.lane, action: packet.action, client: packet.client, turnSignals: packet.turnSignals }
    }, false);

    var url = apiBase() + "/api/chat";
    var out = await postJson(url, packet, 12000);

    // ‚úÖ CONTEXT PERSISTENCE++++: keep engine state across turns (prevents looping / disjoint replies)
    if (out && out.ctx && typeof out.ctx === "object") {
      UI_STATE.ctx = out.ctx;
    }
    // Optional cognition capture (for badge/diagnostics)
    if (out && out.cog && typeof out.cog === "object") {
      UI_STATE.lastCog = out.cog;
    }

    var status = Number(out && (out.__httpStatus || out.status || 0)) || 0;

    setMarionOn(marionPresent(out));
    renderCogBadge(out);

    // LANE HARD-LOCK: never let backend drift change the UI lane.
    // We still include backend lane in NYX_REPLY for telemetry, but UI stays stable.
    var backendLane = safeStr(out && out.lane || "");
    var uiLane = packet.lane;

    var rSig = replySig(out, uiLane);
    var rt = now();
    if(rSig && UI_STATE.__lastReplySig === rSig && (rt - UI_STATE.__lastReplyAt) < 2000){
      diag("HOST v9117l ‚Ä¢ deduped reply");
      setPending(false);
      return out;
    }
    UI_STATE.__lastReplySig = rSig;
    UI_STATE.__lastReplyAt = rt;

    if(out && typeof out.reply === "string" && out.reply){
      var clean = sanitizeReplyText(out.reply);
      await renderAssistantReply(clean);

      // Render Marion/chatEngine suggestions (followUps) if provided
      renderSmartChips(out.followUps || out.followups || out.suggestions || null);

      speak(clean);

      postToParent({
        type:"NYX_REPLY",
        v:CONFIG.version,
        ts:now(),
        reply: out.reply,
        lane: backendLane || uiLane,
        uiLane: uiLane,
        cog: sanitizeCog(out.cog),
        meta: out.meta || {}
      }, false);

      diag("HOST v9117l ‚Ä¢ ok");
    }else{
      var msg = "Hmm. I didn‚Äôt get a clean reply. Try again.";
      if(status === 401 || status === 403) msg = "Auth blocked (401/403). Token/origin mismatch ‚Äî fix the parent config.";
      if(out && out.error === "timeout") msg = "Timeout. Try again.";
      await renderAssistantReply(msg);
      renderSmartChips(null);

      diag("HOST v9117l ‚Ä¢ error " + (status || "unknown"));
      postToParent({
        type:"NYX_ERROR",
        v:CONFIG.version,
        ts:now(),
        status: status,
        error: (out && out.error) || "error",
        lane: backendLane || uiLane,
        uiLane: uiLane,
        cog: sanitizeCog(out && out.cog ? out.cog : null),
        meta: out && out.meta ? out.meta : {}
      }, false);
    }

    setPending(false);
    return out;
    } finally {
      // HARDEN++++: never let UI lock if any downstream render/speech throws
      setPending(false);
    }
  }

  function sendTypedText(){
    var text = (inputEl && inputEl.value) ? String(inputEl.value).trim() : "";
    if(!text) return;

    // transcript: show user message when expanded (and keep it for context)
    pushThread("user", text);
    renderThread();

    var packet = buildIntentPacket({
      text: text,
      chip: UI_STATE.chip,
      lane: UI_STATE.lane,
      action: "user_text",
      intent: "message",
      label: UI_STATE.chip
    });

    if(inputEl) inputEl.value = "";
    return sendPacket(packet);
  }

  if(sendBtn){
    sendBtn.addEventListener("click", function(){ sendTypedText(); });
  }
  if(inputEl){
    inputEl.addEventListener("keydown", function(e){
      if(e.key === "Enter"){
        e.preventDefault();
        sendTypedText();
      }
    });
  }

  // ==========
  // Final init
  // ==========
  setMarionOn(false);
  applyDebugGate();

})();
</script>
</body>
</html>
