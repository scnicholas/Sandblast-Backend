/**
 * ingest_top40weekly_1955_1959.js
 * Non-destructive ingestion for Top40Weekly year pages (1955–1959).
 *
 * Output:
 *   Data/top40weekly/top40weekly_top100_<YEAR>.json
 *
 * Usage:
 *   node Scripts/ingest_top40weekly_1955_1959.js
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import axios from "axios";
import * as cheerio from "cheerio";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUT_DIR = path.join(__dirname, "..", "Data", "top40weekly");
fs.mkdirSync(OUT_DIR, { recursive: true });

const URLS = {
  1955: "https://top40weekly.com/1955-all-charts/",
  1956: "https://top40weekly.com/1956-all-charts/",
  1957: "https://top40weekly.com/1957-all-charts/",
  1958: "https://top40weekly.com/1958-all-charts/",
  1959: "https://top40weekly.com/1959-all-charts/",
};

function clean(s) {
  return String(s || "")
    .replace(/\u00a0/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function looksLikeRank(x) {
  const n = Number(String(x).replace(/[^\d]/g, ""));
  return Number.isFinite(n) && n >= 1 && n <= 200;
}

function normalizeTitleArtist(raw) {
  // Handle common patterns:
  // "Song Title — Artist"
  // "Song Title - Artist"
  // "Artist — Song Title" (rare, but we detect)
  const s = clean(raw);

  // Prefer split on em dash / en dash
  const parts = s.split(/\s[—–-]\s/).map(clean).filter(Boolean);
  if (parts.length === 2) {
    const a = parts[0], b = parts[1];

    // Heuristic: titles often have quotes/parentheses; artists often have "and", "&", "feat"
    const aLooksArtist = /\b(feat\.|ft\.|and|&)\b/i.test(a) || /^[A-Z][\w\s'.-]+$/.test(a);
    const bLooksArtist = /\b(feat\.|ft\.|and|&)\b/i.test(b) || /^[A-Z][\w\s'.-]+$/.test(b);

    // If left looks more like artist and right looks more like title, swap
    // (this is conservative; we mainly want Title left, Artist right)
    if (aLooksArtist && !bLooksArtist) {
      return { title: b, artist: a };
    }
    return { title: a, artist: b };
  }

  // If no clean split, return unknown artist/title fallback
  return { title: s, artist: "" };
}

function pickBestTable($) {
  // Find the table that most resembles a Top 100 list: many rows, rank-ish first column
  const tables = $("table");
  let best = null;
  let bestScore = -1;

  tables.each((_, tbl) => {
    const $tbl = $(tbl);
    const rows = $tbl.find("tr");
    if (rows.length < 30) return;

    let rankHits = 0;
    rows.slice(0, 30).each((i, tr) => {
      const tds = $(tr).find("td");
      if (tds.length < 2) return;
      const c0 = clean($(tds[0]).text());
      if (looksLikeRank(c0)) rankHits++;
    });

    const score = rankHits + Math.min(rows.length / 10, 20);
    if (score > bestScore) {
      bestScore = score;
      best = $tbl;
    }
  });

  return best;
}

function parseYearPage(html, year) {
  const $ = cheerio.load(html);

  const table = pickBestTable($);
  if (!table) {
    throw new Error(`No suitable table found for ${year}`);
  }

  const out = [];
  table.find("tr").each((_, tr) => {
    const tds = $(tr).find("td");
    if (tds.length < 2) return;

    const c0 = clean($(tds[0]).text());
    if (!looksLikeRank(c0)) return;

    const rank = Number(String(c0).replace(/[^\d]/g, ""));
    const c1 = clean($(tds[1]).text());
    const c2 = tds.length >= 3 ? clean($(tds[2]).text()) : "";

    let title = "";
    let artist = "";

    // Common case: [rank, title, artist]
    if (c2) {
      title = c1;
      artist = c2;
    } else {
      // Sometimes [rank, "title — artist"]
      const na = normalizeTitleArtist(c1);
      title = na.title;
      artist = na.artist;
    }

    title = clean(title);
    artist = clean(artist);

    if (!title) title = "Unknown Title";
    if (!artist) artist = "Unknown Artist";

    out.push({
      chart: "Top40Weekly Top 100",
      year,
      rank,
      title,
      artist,
      source: URLS[year],
    });
  });

  // Keep only top 100 if page includes more
  out.sort((a, b) => a.rank - b.rank);
  return out.filter(x => x.rank >= 1 && x.rank <= 100);
}

async function run() {
  for (const year of Object.keys(URLS).map(Number).sort((a,b)=>a-b)) {
    const url = URLS[year];
    console.log(`[ingest] Fetching ${year}: ${url}`);
    const res = await axios.get(url, {
      timeout: 25000,
      headers: {
        "User-Agent": "SandblastNyx/1.0 (ingestion script)",
        "Accept": "text/html,application/xhtml+xml",
      }
    });

    const rows = parseYearPage(res.data, year);
    if (!rows.length) throw new Error(`Parsed 0 rows for ${year}`);

    const outPath = path.join(OUT_DIR, `top40weekly_top100_${year}.json`);

    // Non-destructive: only write if missing, unless you set OVERWRITE=1
    const overwrite = process.env.OVERWRITE === "1";
    if (fs.existsSync(outPath) && !overwrite) {
      console.log(`[ingest] Exists, skipping (set OVERWRITE=1 to replace): ${outPath}`);
      continue;
    }

    fs.writeFileSync(outPath, JSON.stringify(rows, null, 2), "utf8");
    console.log(`[ingest] Wrote ${rows.length} rows → ${outPath}`);
  }

  console.log("[ingest] Done.");
}

run().catch(err => {
  console.error("[ingest] FAILED:", err?.message || err);
  process.exitCode = 1;
});
