"use strict";

/**
 * Scripts/build_top40weekly_50s.js
 *
 * Downloads Top40Weekly year pages for 1955–1959 and extracts the Top 100 list.
 * Writes JSON files into: Data/top40weekly/top40weekly_top100_YYYY.json
 *
 * Safe: does not modify any existing file unless it is the same target output name.
 */

const fs = require("fs");
const path = require("path");
const cheerio = require("cheerio");

const OUT_DIR = path.resolve(process.cwd(), "Data/top40weekly");

const YEAR_URLS = {
  1955: "https://top40weekly.com/1955-all-charts/",
  1956: "https://top40weekly.com/1956-all-charts/",
  1957: "https://top40weekly.com/1957-all-charts/",
  1958: "https://top40weekly.com/1958-all-charts/",
  1959: "https://top40weekly.com/1959-all-charts/",
};

function cleanText(s) {
  return String(s || "")
    .replace(/\u00a0/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function toInt(x) {
  const n = Number(String(x || "").trim());
  return Number.isFinite(n) ? n : null;
}

function looksLikeRankHeader(h) {
  const t = cleanText(h).toLowerCase();
  return (
    t === "#" ||
    t === "no" ||
    t === "no." ||
    t.includes("rank") ||
    t.includes("position") ||
    t === "pos"
  );
}

function looksLikeTitleHeader(h) {
  const t = cleanText(h).toLowerCase();
  return t.includes("title") || t.includes("song");
}

function looksLikeArtistHeader(h) {
  const t = cleanText(h).toLowerCase();
  return t.includes("artist") || t.includes("performer");
}

/**
 * Heuristic: find the best table that contains rank + title + artist.
 */
function extractFromTables($) {
  let best = null; // {score, rows}
  $("table").each((_, tbl) => {
    const $tbl = $(tbl);
    const $firstRow = $tbl.find("tr").first();
    const headers = $firstRow
      .find("th,td")
      .map((i, el) => cleanText($(el).text()))
      .get()
      .filter(Boolean);

    if (!headers.length) return;

    const rankIdx = headers.findIndex(looksLikeRankHeader);
    const titleIdx = headers.findIndex(looksLikeTitleHeader);
    const artistIdx = headers.findIndex(looksLikeArtistHeader);

    // Must have rank + at least (title or artist) to be considered
    if (rankIdx < 0) return;

    const dataRows = [];
    $tbl.find("tr").slice(1).each((__, tr) => {
      const cells = $(tr)
        .find("td,th")
        .map((i, el) => cleanText($(el).text()))
        .get();

      if (!cells.length) return;

      const rk = toInt(cells[rankIdx]);
      if (!rk || rk < 1 || rk > 100) return;

      const title = titleIdx >= 0 ? cleanText(cells[titleIdx]) : "";
      const artist = artistIdx >= 0 ? cleanText(cells[artistIdx]) : "";

      // Some pages may combine title/artist in one column; keep if we have either
      if (!title && !artist) return;

      dataRows.push({ rank: rk, title, artist });
    });

    if (!dataRows.length) return;

    // Score: prefer tables that explicitly have title+artist headers
    const score =
      dataRows.length +
      (titleIdx >= 0 ? 50 : 0) +
      (artistIdx >= 0 ? 50 : 0);

    if (!best || score > best.score) best = { score, rows: dataRows };
  });

  return best ? best.rows : null;
}

/**
 * Fallback: parse list items like "1. Artist — Title" or "1. Title - Artist"
 */
function extractFromLists($) {
  const items = $("li")
    .map((i, el) => cleanText($(el).text()))
    .get()
    .filter((t) => /^\d{1,3}\./.test(t));

  if (!items.length) return null;

  const rows = [];
  for (const line of items) {
    const m = line.match(/^(\d{1,3})\.\s*(.+)$/);
    if (!m) continue;
    const rank = toInt(m[1]);
    if (!rank || rank < 1 || rank > 100) continue;

    const rest = cleanText(m[2]);

    // Try split with em dash / hyphen
    const parts = rest.split(/\s+[—-]\s+/).map(cleanText).filter(Boolean);
    let artist = "";
    let title = "";

    if (parts.length >= 2) {
      // Ambiguity: decide by “feat.” / "&" etc isn't reliable; we’ll assume "Artist — Title"
      artist = parts[0];
      title = parts.slice(1).join(" — ");
    } else {
      // Try "Title by Artist"
      const mb = rest.match(/^(.+?)\s+by\s+(.+)$/i);
      if (mb) {
        title = cleanText(mb[1]);
        artist = cleanText(mb[2]);
      } else {
        // last resort: keep as title
        title = rest;
      }
    }

    rows.push({ rank, artist, title });
  }

  return rows.length ? rows : null;
}

function normalizeRows(rows) {
  const map = new Map();
  for (const r of rows) {
    const rank = toInt(r.rank);
    if (!rank || rank < 1 || rank > 100) continue;

    const artist = cleanText(r.artist) || "Unknown Artist";
    const title = cleanText(r.title) || "Unknown Title";

    // De-dupe by rank; keep first
    if (!map.has(rank)) map.set(rank, { rank, artist, title });
  }

  return Array.from(map.values()).sort((a, b) => a.rank - b.rank);
}

async function fetchHtml(url) {
  const res = await fetch(url, {
    headers: {
      "User-Agent": "SandblastBot/1.0 (data ingestion)",
      Accept: "text/html,*/*",
    },
  });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.text();
}

async function ingestYear(year, url) {
  console.log(`[t40w-50s] Fetch ${year}: ${url}`);
  const html = await fetchHtml(url);
  const $ = cheerio.load(html);

  let rows = extractFromTables($);
  if (!rows || rows.length < 50) rows = extractFromLists($);

  if (!rows || rows.length < 50) {
    throw new Error(
      `Could not reliably extract Top 100 rows for ${year} (rows=${rows ? rows.length : 0})`
    );
  }

  const normalized = normalizeRows(rows);
  console.log(`[t40w-50s] ${year}: extracted ${normalized.length} rows`);

  if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });

  const outPath = path.join(OUT_DIR, `top40weekly_top100_${year}.json`);
  const payload = {
    source: url,
    year: Number(year),
    chart: "Top40Weekly Top 100",
    rows: normalized,
    generatedAt: new Date().toISOString(),
  };

  fs.writeFileSync(outPath, JSON.stringify(payload, null, 2), "utf8");
  console.log(`[t40w-50s] Wrote: ${outPath}`);
}

async function main() {
  const years = Object.keys(YEAR_URLS).map((y) => Number(y)).sort();
  let ok = 0,
    fail = 0;

  for (const y of years) {
    try {
      await ingestYear(y, YEAR_URLS[y]);
      ok++;
    } catch (e) {
      fail++;
      console.error(`[t40w-50s] FAILED ${y}: ${e.message}`);
    }
  }

  console.log(`[t40w-50s] Done. ok=${ok} fail=${fail}`);
  process.exit(fail ? 1 : 0);
}

main().catch((e) => {
  console.error(`[t40w-50s] Fatal: ${e.message}`);
  process.exit(1);
});
