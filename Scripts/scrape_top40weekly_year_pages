"use strict";

const fs = require("fs");
const path = require("path");

// Node 18+ has fetch; you're on Node v24 so you're good.
async function fetchText(url, tries = 3) {
  let lastErr = null;
  for (let i = 0; i < tries; i++) {
    try {
      const res = await fetch(url, {
        headers: { "User-Agent": "SandblastMomentsBot/1.0 (personal use)" }
      });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    } catch (e) {
      lastErr = e;
      await new Promise(r => setTimeout(r, 900 + i * 800));
    }
  }
  throw lastErr;
}

function stripHtml(html) {
  return html
    .replace(/\r/g, "")
    .replace(/<br\s*\/?>/gi, "\n")
    .replace(/<\/p>/gi, "\n")
    .replace(/<\/li>/gi, "\n")
    .replace(/<\/h\d>/gi, "\n")
    .replace(/<[^>]*>/g, "")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, "\"")
    .replace(/&#8217;|&rsquo;/g, "'")
    .replace(/&#8211;|&ndash;/g, "–")
    .replace(/&#8220;|&ldquo;/g, "“")
    .replace(/&#8221;|&rdquo;/g, "”");
}

function yearFromUrl(url) {
  const m = String(url).match(/top-100-songs-of-(\d{4})\/?$/i);
  return m ? Number(m[1]) : null;
}

function findStartIndex(lines, year) {
  const patterns = [
    new RegExp(`^top\\s*100\\s*songs\\s*of\\s*${year}$`, "i"),
    new RegExp(`^top\\s*songs\\s*of\\s*${year}$`, "i"),
    new RegExp(`^top\\s*songs\\s*from\\s*${year}$`, "i"),
  ];

  for (let i = 0; i < lines.length; i++) {
    const l = lines[i].trim();
    if (patterns.some(rx => rx.test(l))) return i;
  }
  return -1;
}

function parseTop100YearPage(text, year) {
  const lines = stripHtml(text)
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);

  const startIdx = findStartIndex(lines, year);
  if (startIdx === -1) {
    return { year, items: [], warn: `Could not find header block for year ${year}` };
  }

  const items = [];
  for (let i = startIdx + 1; i < lines.length; i++) {
    const l = lines[i];

    // Stop when we hit the "More XX’s Content" section or navigation blocks
    if (/^more\s+\d{2}['’]s\s+content$/i.test(l)) break;

    // Primary record line: "1 Joy to the World"
    const m = l.match(/^(\d{1,3})\s+(.*)$/);
    if (!m) continue;

    const rank = Number(m[1]);
    let title = m[2].trim();

    // Some titles contain trailing extra spacing; keep as-is otherwise.
    if (!title) continue;

    // Next non-rank line is artist (as per page description)
    let artist = "";
    for (let j = i + 1; j < lines.length; j++) {
      const nl = lines[j];

      // If next entry starts, stop
      if (/^\d{1,3}\s+/.test(nl)) break;

      // Skip obvious boilerplate
      if (/^page contents$/i.test(nl)) continue;
      if (/^songs\s+\d+\s*[–-]\s*\d+$/i.test(nl)) continue;
      if (/^these are the top 100 songs/i.test(nl)) continue;
      if (/^the song title is at the top/i.test(nl)) continue;
      if (/^you can find links to/i.test(nl)) continue;
      if (/^we welcome you to join/i.test(nl)) continue;

      artist = nl.trim();
      if (artist) {
        i = j; // advance outer loop to after artist
        break;
      }
    }

    if (artist) {
      items.push({ year, rank, artist, title, chart: "Top40Weekly Top 100" });
    }
  }

  return { year, items, warn: items.length ? null : `No items parsed for year ${year}` };
}

function toCsv(rows) {
  const header = ["year","rank","artist","title","chart"];
  const esc = (v) => {
    const s = String(v ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const out = [header.join(",")];
  for (const r of rows) {
    out.push([r.year, r.rank, r.artist, r.title, r.chart].map(esc).join(","));
  }
  return out.join("\n") + "\n";
}

(async function main() {
  const outPath = process.argv[2];
  const urls = process.argv.slice(3);

  if (!outPath || urls.length === 0) {
    console.error("Usage: node scripts/scrape_top40weekly_year_pages.js <out.csv> <url1> <url2> ...");
    process.exit(1);
  }

  const absOut = path.resolve(process.cwd(), outPath);
  fs.mkdirSync(path.dirname(absOut), { recursive: true });

  let all = [];
  for (const url of urls) {
    const year = yearFromUrl(url);
    if (!year) {
      console.error("[WARN] Skipping (could not extract year from URL):", url);
      continue;
    }
    console.error("[GET]", url);
    const html = await fetchText(url);
    const parsed = parseTop100YearPage(html, year);
    if (parsed.warn) console.error("[WARN]", parsed.warn);
    console.error("[OK]", year, "items=", parsed.items.length);
    all = all.concat(parsed.items);

    // Be polite to the site
    await new Promise(r => setTimeout(r, 900));
  }

  fs.writeFileSync(absOut, toCsv(all), "utf8");
  console.error("[DONE] wrote rows=", all.length);
  console.error("[OUT]", absOut);
})().catch(e => {
  console.error("[ERR]", e && e.stack ? e.stack : e);
  process.exit(1);
});
