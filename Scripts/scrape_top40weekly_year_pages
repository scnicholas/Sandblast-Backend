"use strict";

const fs = require("fs");
const path = require("path");

async function fetchText(url, tries = 3) {
  let lastErr = null;
  for (let i = 0; i < tries; i++) {
    try {
      const res = await fetch(url, { headers: { "User-Agent": "SandblastMomentsBot/3.0" } });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    } catch (e) {
      lastErr = e;
      await new Promise(r => setTimeout(r, 900 + i * 800));
    }
  }
  throw lastErr;
}

function yearFromUrl(url) {
  const m = String(url).match(/top-100-songs-of-(\d{4})\/?$/i);
  return m ? Number(m[1]) : null;
}

function htmlDecode(s) {
  return String(s || "")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, "\"")
    .replace(/&#8217;|&rsquo;/g, "'")
    .replace(/&#8211;|&ndash;/g, "–")
    .replace(/&#8220;|&ldquo;/g, "“")
    .replace(/&#8221;|&rdquo;/g, "”");
}

function extractEntryContent(html) {
  // Try common WP container patterns first
  const m =
    html.match(/<div[^>]+class="[^"]*entry-content[^"]*"[^>]*>([\s\S]*?)<\/div>\s*<\/(article|div)>/i) ||
    html.match(/<div[^>]+class="[^"]*the_content[^"]*"[^>]*>([\s\S]*?)<\/div>/i);

  return m ? m[1] : html;
}

function toLines(html) {
  const h = html
    .replace(/\r/g, "")
    .replace(/<br\s*\/?>/gi, "\n")
    .replace(/<\/p>/gi, "\n")
    .replace(/<\/li>/gi, "\n")
    .replace(/<\/h\d>/gi, "\n");

  const text = htmlDecode(h.replace(/<[^>]*>/g, " "));
  return text
    .split("\n")
    .map(s => s.replace(/\s+/g, " ").trim())
    .filter(Boolean);
}

function parseRankTitleArtist(lines, year) {
  const items = [];
  for (let i = 0; i < lines.length; i++) {
    const m = lines[i].match(/^(\d{1,3})\s+(.+)$/);
    if (!m) continue;
    const rank = Number(m[1]);
    if (!(rank >= 1 && rank <= 100)) continue;

    const title = m[2].trim();
    if (!title) continue;

    // Find next non-rank line as artist
    let artist = "";
    for (let j = i + 1; j < lines.length; j++) {
      if (/^\d{1,3}\s+/.test(lines[j])) break;
      const cand = lines[j].trim();
      // skip boilerplate-ish lines
      if (/^page contents$/i.test(cand)) continue;
      if (/^songs\s+\d+/i.test(cand)) continue;
      if (/^more\s+\d{2}/i.test(cand)) break;
      artist = cand;
      i = j;
      break;
    }

    if (artist) items.push({ year, rank, artist, title, chart: "Top40Weekly Top 100" });
  }
  // Dedup and sort
  const seen = new Set();
  const out = [];
  for (const it of items) {
    const k = `${it.year}||${it.rank}||${it.artist.toLowerCase()}||${it.title.toLowerCase()}`;
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(it);
  }
  out.sort((a,b)=>a.rank-b.rank);
  return out;
}

function toCsv(rows) {
  const header = ["year","rank","artist","title","chart"];
  const esc = (v) => {
    const s = String(v ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const out = [header.join(",")];
  for (const r of rows) out.push([r.year, r.rank, r.artist, r.title, r.chart].map(esc).join(","));
  return out.join("\n") + "\n";
}

(async function main() {
  const outPath = process.argv[2];
  const urls = process.argv.slice(3);
  if (!outPath || urls.length === 0) {
    console.error("Usage: node scripts/scrape_top40weekly_year_pages.js <out.csv> <url1> <url2> ...");
    process.exit(1);
  }

  const absOut = path.resolve(process.cwd(), outPath);
  fs.mkdirSync(path.dirname(absOut), { recursive: true });

  let all = [];
  for (const url of urls) {
    const year = yearFromUrl(url);
    if (!year) {
      console.error("[WARN] Skipping (could not extract year):", url);
      continue;
    }
    console.error("[GET]", url);
    const html = await fetchText(url);
    const content = extractEntryContent(html);
    const lines = toLines(content);
    const items = parseRankTitleArtist(lines, year);
    console.error("[OK]", year, "items=", items.length);

    // Debug hint if still low: write a tiny sample lines file
    if (items.length < 50) {
      const debugPath = `./Data/_debug_lines_${year}.txt`;
      fs.writeFileSync(debugPath, lines.slice(0,400).join("\n") + "\n", "utf8");
      console.error("[DBG] wrote", debugPath, "(first 400 lines)");
    }

    all = all.concat(items);
    await new Promise(r => setTimeout(r, 900));
  }

  fs.writeFileSync(absOut, toCsv(all), "utf8");
  console.error("[DONE] wrote rows=", all.length);
  console.error("[OUT]", absOut);
})().catch(e => {
  console.error("[ERR]", e && e.stack ? e.stack : e);
  process.exit(1);
});
