"use strict";

const fs = require("fs");
const path = require("path");

// Node 18+ has fetch; you're on Node v24 so you're good.
async function fetchText(url, tries = 3) {
  let lastErr = null;
  for (let i = 0; i < tries; i++) {
    try {
      const res = await fetch(url, {
        headers: { "User-Agent": "SandblastMomentsBot/1.0 (personal use)" }
      });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    } catch (e) {
      lastErr = e;
      await new Promise(r => setTimeout(r, 800 + i * 800));
    }
  }
  throw lastErr;
}

function stripHtml(html) {
  return html
    .replace(/\r/g, "")
    .replace(/<br\s*\/?>/gi, "\n")
    .replace(/<\/p>/gi, "\n")
    .replace(/<\/li>/gi, "\n")
    .replace(/<\/h\d>/gi, "\n")
    .replace(/<[^>]*>/g, "")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, "\"")
    .replace(/&#8217;|&rsquo;/g, "'")
    .replace(/&#8211;|&ndash;/g, "–")
    .replace(/&#8220;|&ldquo;/g, "“")
    .replace(/&#8221;|&rdquo;/g, "”");
}

function yearFromUrl(url) {
  const m = String(url).match(/top-100-songs-of-(\d{4})\/?$/i);
  return m ? Number(m[1]) : null;
}

function parseTop100YearPage(text, year) {
  // We’re going to find the section starting at "Top Songs of YYYY"
  const lines = stripHtml(text)
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);

  const startIdx = lines.findIndex(l => l.toLowerCase() === `top songs of ${year}`.toLowerCase());
  if (startIdx === -1) {
    return { year, items: [], warn: `Could not find section header: Top Songs of ${year}` };
  }

  // Parse “rank title” lines followed by an artist line
  const items = [];
  for (let i = startIdx + 1; i < lines.length; i++) {
    const l = lines[i];

    // stop if we hit another major header or navigation-like block
    if (/^top\s+100\s+songs/i.test(l) && i > startIdx + 3) break;
    if (/^top\s+songs\s+of\s+\d{4}$/i.test(l) && i > startIdx + 3) break;

    const m = l.match(/^(\d{1,3})\s+(.*)$/);
    if (!m) continue;

    const rank = Number(m[1]);
    const title = m[2].trim();

    // find next non-rank line as artist
    let artist = "";
    for (let j = i + 1; j < lines.length; j++) {
      const nl = lines[j];
      if (/^\d{1,3}\s+/.test(nl)) break; // next entry started
      // ignore obvious boilerplate
      if (/^this blog post/i.test(nl)) continue;
      if (/^displayed with the song titles/i.test(nl)) continue;
      artist = nl.trim();
      i = j; // advance outer loop
      break;
    }

    if (artist) {
      items.push({ year, rank, artist, title, chart: "Top40Weekly Top 100" });
    }
  }

  return { year, items, warn: items.length ? null : `No items parsed for year ${year}` };
}

function toCsv(rows) {
  const header = ["year","rank","artist","title","chart"];
  const esc = (v) => {
    const s = String(v ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const out = [header.join(",")];
  for (const r of rows) {
    out.push([r.year, r.rank, r.artist, r.title, r.chart].map(esc).join(","));
  }
  return out.join("\n") + "\n";
}

(async function main() {
  const outPath = process.argv[2];
  const urls = process.argv.slice(3);

  if (!outPath || urls.length === 0) {
    console.error("Usage: node scripts/scrape_top40weekly_year_pages.js <out.csv> <url1> <url2> ...");
    process.exit(1);
  }

  const absOut = path.resolve(process.cwd(), outPath);
  fs.mkdirSync(path.dirname(absOut), { recursive: true });

  let all = [];
  for (const url of urls) {
    const year = yearFromUrl(url);
    if (!year) {
      console.error("[WARN] Skipping (could not extract year from URL):", url);
      continue;
    }
    console.error("[GET]", url);
    const html = await fetchText(url);
    const parsed = parseTop100YearPage(html, year);
    if (parsed.warn) console.error("[WARN]", parsed.warn);
    console.error("[OK]", year, "items=", parsed.items.length);
    all = all.concat(parsed.items);

    // Be polite to the site
    await new Promise(r => setTimeout(r, 900));
  }

  fs.writeFileSync(absOut, toCsv(all), "utf8");
  console.error("[DONE] wrote rows=", all.length);
  console.error("[OUT]", absOut);
})().catch(e => {
  console.error("[ERR]", e && e.stack ? e.stack : e);
  process.exit(1);
});
