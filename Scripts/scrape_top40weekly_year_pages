"use strict";

const fs = require("fs");
const path = require("path");

async function fetchText(url, tries = 3) {
  let lastErr = null;
  for (let i = 0; i < tries; i++) {
    try {
      const res = await fetch(url, { headers: { "User-Agent": "SandblastMomentsBot/3.6" } });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return await res.text();
    } catch (e) {
      lastErr = e;
      await new Promise((r) => setTimeout(r, 900 + i * 800));
    }
  }
  throw lastErr;
}

function yearFromUrl(url) {
  const m = String(url).match(/top-100-songs-of-(\d{4})\/?$/i);
  return m ? Number(m[1]) : null;
}

function htmlDecode(s) {
  return String(s || "")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#8217;|&rsquo;/g, "'")
    .replace(/&#8211;|&ndash;/g, "–")
    .replace(/&#8212;|&mdash;/g, "—")
    .replace(/&#8220;|&ldquo;/g, "“")
    .replace(/&#8221;|&rdquo;/g, "”");
}

function stripTags(s) {
  return htmlDecode(String(s || ""))
    .replace(/<script[\s\S]*?<\/script>/gi, " ")
    .replace(/<style[\s\S]*?<\/style>/gi, " ")
    .replace(/<[^>]*>/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function extractEntryContent(html) {
  const m =
    html.match(/<div[^>]+class="[^"]*\bentry-content\b[^"]*"[^>]*>([\s\S]*?)<\/div>/i) ||
    html.match(/<div[^>]+class="[^"]*\bthe_content\b[^"]*"[^>]*>([\s\S]*?)<\/div>/i);
  return m ? m[1] : html;
}

function looksLikeTitle(s) {
  const t = String(s || "").trim();
  if (!t) return false;
  if (t.length < 2) return false;
  if (/^songs\b/i.test(t)) return false;
  if (/^top\s+100\b/i.test(t)) return false;
  if (/^page contents$/i.test(t)) return false;
  return true;
}
function looksLikeArtist(s) {
  const t = String(s || "").trim();
  if (!t) return false;
  if (t.length < 2) return false;
  if (/^songs\b/i.test(t)) return false;
  if (/^page contents$/i.test(t)) return false;
  return true;
}

function parsePairsInOrder(contentHtml) {
  const h = String(contentHtml || "").replace(/\r/g, "").replace(/\n/g, " ");

  const pairs = [];

  // A) Table rows: [title, artist] or [rank?, title, artist]
  const trRe = /<tr[^>]*>([\s\S]*?)<\/tr>/gi;
  let tr;
  while ((tr = trRe.exec(h)) !== null) {
    const row = tr[1];
    const tds = [...row.matchAll(/<t[dh][^>]*>([\s\S]*?)<\/t[dh]>/gi)].map((x) => x[1]);
    if (tds.length < 2) continue;

    const cols = tds.map(stripTags).filter(Boolean);
    if (cols.length < 2) continue;

    // Heuristic: choose last two meaningful columns as title/artist
    // Many pages are [rank,title,artist]; some are [title,artist]
    let title = "";
    let artist = "";

    if (cols.length >= 3) {
      title = cols[1];
      artist = cols[2];
    } else {
      title = cols[0];
      artist = cols[1];
    }

    // Title may include dash-artist
    if (title && !artist && /[-–—]/.test(title)) {
      const parts = title.split(/[-–—]/).map((s) => s.trim()).filter(Boolean);
      if (parts.length >= 2) {
        title = parts[0];
        artist = parts.slice(1).join(" — ");
      }
    }

    if (looksLikeTitle(title) && looksLikeArtist(artist)) {
      pairs.push({ title: title.trim(), artist: artist.trim(), _src: "tr" });
    }
  }

  // B) List items: "Title – Artist" or "Title by Artist"
  const liRe = /<li[^>]*>([\s\S]*?)<\/li>/gi;
  let li;
  while ((li = liRe.exec(h)) !== null) {
    const txt = stripTags(li[1]);
    if (!txt) continue;

    // Remove leading rank tokens if present (but we do NOT rely on them)
    const cleaned = txt.replace(/^\s*\d{1,3}\s*[\.\)\-–:]?\s*/, "");

    const m =
      cleaned.match(/^(.+?)\s+(?:by)\s+(.+)$/i) ||
      cleaned.match(/^(.+?)\s*[-–—]\s*(.+)$/);

    if (!m) continue;
    const title = String(m[1] || "").trim();
    const artist = String(m[2] || "").trim();
    if (looksLikeTitle(title) && looksLikeArtist(artist)) {
      pairs.push({ title, artist, _src: "li" });
    }
  }

  // C) Strong-based blocks: <strong>Title</strong> then nearby artist
  const strongRe = /<strong[^>]*>([\s\S]*?)<\/strong>/gi;
  let sm;
  while ((sm = strongRe.exec(h)) !== null) {
    const strongTxt = stripTags(sm[1]);
    if (!strongTxt) continue;

    // Strip leading rank token if present
    const title = strongTxt.replace(/^\s*\d{1,3}\s*[\.\)\-–:]?\s*/, "").trim();
    if (!looksLikeTitle(title)) continue;

    // Look ahead for artist in next ~1200 chars
    const start = strongRe.lastIndex;
    const window = h.slice(start, start + 1200);
    const winTxt = stripTags(window);

    // Try "by" or dash patterns in the nearby text
    let artist = "";
    const m =
      winTxt.match(/\bby\s+([^|·]{2,80})/i) ||
      winTxt.match(/[-–—]\s*([^|·]{2,80})/);

    if (m) artist = String(m[1] || "").trim();

    if (looksLikeArtist(artist)) {
      pairs.push({ title, artist, _src: "strong" });
    }
  }

  // D) Normalize + dedupe (keep order, remove exact duplicates & near-consecutive duplicates)
  const out = [];
  const seen = new Set();
  let lastKey = "";

  for (const p of pairs) {
    const key = `${p.title.toLowerCase()}||${p.artist.toLowerCase()}`;
    if (key === lastKey) continue; // consecutive dup
    lastKey = key;

    // Don’t eliminate all repeats across the page too aggressively,
    // but do block obvious duplicates
    if (seen.has(key)) continue;
    seen.add(key);

    out.push({ title: p.title, artist: p.artist });
  }

  return out;
}

function toCsv(rows) {
  const header = ["year", "rank", "artist", "title", "chart"];
  const esc = (v) => {
    const s = String(v ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
    return s;
  };
  const out = [header.join(",")];
  for (const r of rows) out.push([r.year, r.rank, r.artist, r.title, r.chart].map(esc).join(","));
  return out.join("\n") + "\n";
}

(async function main() {
  const outPath = process.argv[2];
  const urls = process.argv.slice(3);
  if (!outPath || urls.length === 0) {
    console.error("Usage: node scripts/scrape_top40weekly_year_pages.js <out.csv> <url1> <url2> ...");
    process.exit(1);
  }

  const absOut = path.resolve(process.cwd(), outPath);
  fs.mkdirSync(path.dirname(absOut), { recursive: true });

  let all = [];
  for (const url of urls) {
    const year = yearFromUrl(url);
    if (!year) {
      console.error("[WARN] Skipping (could not extract year):", url);
      continue;
    }

    console.error("[GET]", url);
    const html = await fetchText(url);
    const content = extractEntryContent(html);

    const pairs = parsePairsInOrder(content);

    // Assign rank by order and cap at 100
    const rows = pairs.slice(0, 100).map((p, idx) => ({
      year,
      rank: idx + 1,
      artist: p.artist,
      title: p.title,
      chart: "Top40Weekly Top 100",
    }));

    console.error("[OK]", year, "items=", rows.length);
    if (rows.length < 100) console.error("[WARN]", year, "only found", rows.length, "unique title/artist pairs");

    all = all.concat(rows);
    await new Promise((r) => setTimeout(r, 900));
  }

  fs.writeFileSync(absOut, toCsv(all), "utf8");
  console.error("[DONE] wrote rows=", all.length);
  console.error("[OUT]", absOut);
})().catch((e) => {
  console.error("[ERR]", e && e.stack ? e.stack : e);
  process.exit(1);
});
