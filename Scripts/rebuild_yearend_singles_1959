const fs = require("fs");
const path = require("path");

const FILE = path.resolve(
  process.cwd(),
  "Data/wikipedia/billboard_yearend_singles_1950_1959.json"
);

const REST_URL =
  "https://en.wikipedia.org/api/rest_v1/page/html/Billboard_Year-End_Hot_100_singles_of_1959";
const PAGE_URL =
  "https://en.wikipedia.org/wiki/Billboard_Year-End_Hot_100_singles_of_1959";

function decodeHtml(s) {
  return String(s || "")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/\s+/g, " ")
    .trim();
}

function stripTags(html) {
  return decodeHtml(
    String(html || "")
      .replace(/<br\s*\/?>/gi, " ")
      .replace(/<sup[^>]*>.*?<\/sup>/gis, "")
      .replace(/<style[\s\S]*?<\/style>/gis, "")
      .replace(/<script[\s\S]*?<\/script>/gis, "")
      .replace(/<[^>]+>/g, " ")
  );
}

function cleanField(s) {
  let t = decodeHtml(s);
  t = t.replace(/^"\s*/g, "").replace(/\s*"$/g, "");
  t = t.replace(/\s+/g, " ").trim();
  return t;
}

function extractAllWikitables(html) {
  const tables = [];
  const re =
    /<table[^>]*class="[^"]*wikitable[^"]*"[^>]*>[\s\S]*?<\/table>/gi;
  let m;
  while ((m = re.exec(html))) tables.push(m[0]);
  return tables;
}

function extractRows(tableHtml) {
  const trs = tableHtml.match(/<tr[\s\S]*?<\/tr>/gi) || [];
  return trs
    .map((tr) => {
      const cells = (tr.match(/<(td|th)[\s\S]*?<\/(td|th)>/gi) || [])
        .map((cell) => stripTags(cell))
        .map((x) => x.replace(/\s+/g, " ").trim())
        .filter(Boolean);
      return cells;
    })
    .filter((r) => r.length >= 2);
}

function parseRank(s) {
  const n = Number(String(s || "").replace(/[^\d]/g, ""));
  return Number.isFinite(n) && n > 0 ? n : null;
}

function looksLikeHeaderRow(row) {
  const j = row.join(" ").toLowerCase();
  return (
    j.includes("rank") ||
    j.includes("no.") ||
    j.includes("single") ||
    j.includes("title") ||
    j.includes("artist") ||
    j.includes("№")
  );
}

function buildFromRows(trRows) {
  const built = [];
  for (const r of trRows) {
    if (looksLikeHeaderRow(r)) continue;

    const rk = parseRank(r[0]);
    if (!rk) continue;

    const titleRaw = r[1] || "";
    const artistRaw = r[2] || r[3] || "";

    const title = cleanField(titleRaw);
    const artist = cleanField(artistRaw);

    if (!title || !artist) continue;

    built.push({ rk, title, artist });
  }
  built.sort((a, b) => a.rk - b.rk);
  return built;
}

// Score tables: prefer ones that look like a complete 1–100 list.
// - more rows is good
// - fewer rank gaps is good
// - having rank 1–10 present is very good
function scoreTable(built) {
  if (!built.length) return -1;

  const ranks = built.map((x) => x.rk);
  const uniq = new Set(ranks);
  const maxRank = Math.max(...ranks);

  // Count gaps in 1..min(100,maxRank)
  const limit = Math.min(100, maxRank);
  let missing = 0;
  for (let i = 1; i <= Math.min(30, limit); i++) {
    if (!uniq.has(i)) missing++;
  }

  let top10Missing = 0;
  for (let i = 1; i <= 10; i++) {
    if (!uniq.has(i)) top10Missing++;
  }

  // Primary: row count, then penalize missing in top 10 and top 30
  return built.length * 10 - top10Missing * 200 - missing * 50;
}

// Normalize to sequential ranks (1..N) so Nyx never shows rank gaps.
// Keeps original order by rk, but overwrites rank field.
function normalizeSequentialRanks(built) {
  const out = built.slice().sort((a, b) => a.rk - b.rk);
  let seq = 1;
  for (const item of out) {
    item.rk = seq++;
  }
  return out;
}

async function fetchText(url) {
  const res = await fetch(url, {
    headers: { "User-Agent": "sandblast-rebuild/1959/1.2" },
  });
  return {
    ok: res.ok,
    status: res.status,
    statusText: res.statusText,
    text: await res.text(),
    url,
  };
}

(async () => {
  if (!fs.existsSync(FILE)) {
    console.error("Missing JSON file:", FILE);
    process.exit(1);
  }

  const doc = JSON.parse(fs.readFileSync(FILE, "utf8"));
  const rows = Array.isArray(doc.rows) ? doc.rows : [];

  console.log("=== Rebuild 1959 Year-End Singles ===");
  console.log("Target JSON:", FILE);

  console.log("Fetching (REST):", REST_URL);
  let f = await fetchText(REST_URL);

  if (!f.ok) {
    console.log("REST fetch failed:", f.status, f.statusText);
    console.log("Fetching (PAGE):", PAGE_URL);
    f = await fetchText(PAGE_URL);
    if (!f.ok) {
      console.error("PAGE fetch failed:", f.status, f.statusText);
      process.exit(1);
    }
  }

  const html = f.text;
  const tables = extractAllWikitables(html);
  console.log("Wikitables found:", tables.length);

  if (!tables.length) {
    console.error("No wikitables found. Page layout changed.");
    process.exit(1);
  }

  let bestBuilt = [];
  let bestIdx = -1;
  let bestScore = -1;

  for (let i = 0; i < tables.length; i++) {
    const trRows = extractRows(tables[i]);
    const built = buildFromRows(trRows);
    const score = scoreTable(built);

    // Debug visibility
    if (built.length) {
      const ranks = built.map((x) => x.rk);
      const uniq = new Set(ranks);
      const missTop10 = Array.from({ length: 10 }, (_, k) => k + 1).filter(
        (n) => !uniq.has(n)
      );
      console.log(
        `table#${i} rows=${built.length} score=${score} missingTop10=${missTop10.join(",") || "none"}`
      );
    }

    if (score > bestScore) {
      bestScore = score;
      bestBuilt = built;
      bestIdx = i;
    }
  }

  console.log("Best table index:", bestIdx);
  console.log("Parsed ranked rows:", bestBuilt.length);
  console.log("Best score:", bestScore);

  if (!bestBuilt.length) {
    console.error("Parsed 0 usable rows. Sample extracted rows:");
    const trRows = extractRows(tables[0]);
    console.error(trRows.slice(0, 12));
    process.exit(1);
  }

  // ✅ Normalize ranks to remove gaps like missing #4
  const normalized = normalizeSequentialRanks(bestBuilt);

  // Store up to 100.
  const final1959 = normalized
    .filter((x) => x.rk >= 1 && x.rk <= 100)
    .slice(0, 100)
    .map((x) => ({
      chart: "Billboard Year-End Singles",
      year: 1959,
      rank: x.rk,
      title: x.title,
      artist: x.artist,
      source: PAGE_URL,
    }));

  console.log("Final rows to write:", final1959.length);

  const kept = rows.filter((r) => Number(r.year) !== 1959);
  doc.rows = kept.concat(final1959);
  doc.generatedAt = new Date().toISOString();
  doc.sources = doc.sources || {};
  doc.sources["1959"] = PAGE_URL;

  fs.writeFileSync(FILE, JSON.stringify(doc, null, 2), "utf8");
  console.log("WROTE JSON OK.");
})();
