const fs = require("fs");
const path = require("path");

const FILE = path.resolve(
  process.cwd(),
  "Data/wikipedia/billboard_yearend_singles_1950_1959.json"
);

// ✅ Correct 1959 page
const REST_URL =
  "https://en.wikipedia.org/api/rest_v1/page/html/Billboard_Year-End_Hot_100_singles_of_1959";
const PAGE_URL =
  "https://en.wikipedia.org/wiki/Billboard_Year-End_Hot_100_singles_of_1959";

function decodeHtml(s) {
  return String(s || "")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/\s+/g, " ")
    .trim();
}

function stripTags(html) {
  return decodeHtml(
    String(html || "")
      .replace(/<br\s*\/?>/gi, " ")
      .replace(/<sup[^>]*>.*?<\/sup>/gis, "")
      .replace(/<style[\s\S]*?<\/style>/gis, "")
      .replace(/<script[\s\S]*?<\/script>/gis, "")
      .replace(/<[^>]+>/g, " ")
  );
}

function cleanField(s) {
  let t = decodeHtml(s);
  // remove wrapping quotes like: " Title "
  t = t.replace(/^"\s*/g, "").replace(/\s*"$/g, "");
  // collapse spaces again
  t = t.replace(/\s+/g, " ").trim();
  return t;
}

function extractAllWikitables(html) {
  const tables = [];
  const re =
    /<table[^>]*class="[^"]*wikitable[^"]*"[^>]*>[\s\S]*?<\/table>/gi;
  let m;
  while ((m = re.exec(html))) tables.push(m[0]);
  return tables;
}

function extractRows(tableHtml) {
  const trs = tableHtml.match(/<tr[\s\S]*?<\/tr>/gi) || [];
  return trs
    .map((tr) => {
      const cells = (tr.match(/<(td|th)[\s\S]*?<\/(td|th)>/gi) || [])
        .map((cell) => stripTags(cell))
        .map((x) => x.replace(/\s+/g, " ").trim())
        .filter(Boolean);
      return cells;
    })
    .filter((r) => r.length >= 2);
}

function parseRank(s) {
  const n = Number(String(s || "").replace(/[^\d]/g, ""));
  return Number.isFinite(n) && n > 0 ? n : null;
}

function looksLikeHeaderRow(row) {
  const j = row.join(" ").toLowerCase();
  return (
    j.includes("rank") ||
    j.includes("no.") ||
    j.includes("single") ||
    j.includes("title") ||
    j.includes("artist") ||
    j === "№ title artist(s)" ||
    j.includes("№")
  );
}

// Page layout is usually: [№, Title, Artist(s)]
// But sometimes the artist column shifts; allow r[3] as fallback.
function buildFromRows(trRows) {
  const built = [];
  for (const r of trRows) {
    if (looksLikeHeaderRow(r)) continue;

    const rk = parseRank(r[0]);
    if (!rk) continue;

    const titleRaw = r[1] || "";
    const artistRaw = r[2] || r[3] || ""; // ✅ SHIFT-FALLBACK FIX

    const title = cleanField(titleRaw);
    const artist = cleanField(artistRaw);

    if (!title || !artist) continue;

    built.push({ rk, title, artist });
  }
  built.sort((a, b) => a.rk - b.rk);
  return built;
}

async function fetchText(url) {
  const res = await fetch(url, {
    headers: { "User-Agent": "sandblast-rebuild/1959/1.1" },
  });
  return {
    ok: res.ok,
    status: res.status,
    statusText: res.statusText,
    text: await res.text(),
    url,
  };
}

(async () => {
  if (!fs.existsSync(FILE)) {
    console.error("Missing JSON file:", FILE);
    process.exit(1);
  }

  const doc = JSON.parse(fs.readFileSync(FILE, "utf8"));
  const rows = Array.isArray(doc.rows) ? doc.rows : [];

  console.log(
    "=== Rebuild 1959 Year-End Singles (from Billboard Year-End Hot 100 Singles of 1959) ==="
  );
  console.log("Target JSON:", FILE);

  console.log("Fetching (REST):", REST_URL);
  let f = await fetchText(REST_URL);

  if (!f.ok) {
    console.log("REST fetch failed:", f.status, f.statusText);
    console.log("Fetching (PAGE):", PAGE_URL);
    f = await fetchText(PAGE_URL);
    if (!f.ok) {
      console.error("PAGE fetch failed:", f.status, f.statusText);
      process.exit(1);
    }
  }

  const html = f.text;
  const tables = extractAllWikitables(html);
  console.log("Wikitables found:", tables.length);

  if (!tables.length) {
    console.error("No wikitables found. Page layout changed.");
    process.exit(1);
  }

  let bestBuilt = [];
  let bestIdx = -1;

  for (let i = 0; i < tables.length; i++) {
    const trRows = extractRows(tables[i]);
    const built = buildFromRows(trRows);
    if (built.length > bestBuilt.length) {
      bestBuilt = built;
      bestIdx = i;
    }
  }

  console.log("Best table index:", bestIdx);
  console.log("Parsed ranked rows:", bestBuilt.length);

  const final1959 = bestBuilt
    .filter((x) => x.rk >= 1 && x.rk <= 100)
    .slice(0, 100)
    .map((x) => ({
      chart: "Billboard Year-End Singles",
      year: 1959,
      rank: x.rk,
      title: x.title,
      artist: x.artist,
      source: PAGE_URL,
    }));

  console.log("Final rows to write:", final1959.length);

  if (!final1959.length) {
    console.error("Parsed 0 usable rows. Sample extracted rows:");
    const trRows = extractRows(tables[bestIdx]);
    console.error(trRows.slice(0, 12));
    process.exit(1);
  }

  // Remove any existing 1959 rows, append rebuilt
  const kept = rows.filter((r) => Number(r.year) !== 1959);
  doc.rows = kept.concat(final1959);
  doc.generatedAt = new Date().toISOString();
  doc.sources = doc.sources || {};
  doc.sources["1959"] = PAGE_URL;

  fs.writeFileSync(FILE, JSON.stringify(doc, null, 2), "utf8");
  console.log("WROTE JSON OK.");
})();
