"use strict";

/**
 * Scripts/ingest_top40weekly_60s_top100_v1.js
 *
 * Reads:
 *   Data/raw/top40weekly/top-100-songs-of-the-60s.html
 *
 * Writes:
 *   Data/top100_top40weekly_1960s_v1.json
 *
 * Output rows:
 *   { year, rank, artist, title, source }
 *
 * Notes:
 * - Structure-first parsing: li/tr/p blocks before plain text fallback
 * - More robust section finder: id/name/href + year headers
 * - Detects bot/challenge pages and exits with a clear message
 */

const fs = require("fs");
const path = require("path");

const ROOT = path.resolve(__dirname, "..");
const IN_FILE = path.join(
  ROOT,
  "Data",
  "raw",
  "top40weekly",
  "top-100-songs-of-the-60s.html"
);
const OUT_FILE = path.join(ROOT, "Data", "top100_top40weekly_1960s_v1.json");

const SOURCE = "Top40Weekly — Top 100 Songs of the 60s";

function cleanText(s) {
  return String(s || "")
    .replace(/\u200B/g, "")
    .replace(/&nbsp;/g, " ")
    .replace(/&#8217;|&rsquo;/g, "'")
    .replace(/&#8220;|&#8221;|&ldquo;|&rdquo;/g, '"')
    .replace(/&amp;/g, "&")
    .replace(/\s+/g, " ")
    .trim();
}

function decodeCommonEntities(s) {
  // keep it tiny and deterministic (no external deps)
  return cleanText(String(s || ""))
    .replace(/&quot;/g, '"')
    .replace(/&#39;|&apos;/g, "'")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&nbsp;/g, " ");
}

function stripTags(html) {
  return cleanText(
    String(html || "")
      .replace(/<script[\s\S]*?<\/script>/gi, " ")
      .replace(/<style[\s\S]*?<\/style>/gi, " ")
      .replace(/<\/(p|div|tr|li|h\d|br|table)>/gi, "\n")
      .replace(/<br\s*\/?>/gi, "\n")
      .replace(/<[^>]+>/g, " ")
  );
}

function looksLikeBotBlock(html) {
  const t = String(html || "").toLowerCase();
  return (
    t.includes("just a moment") ||
    t.includes("verify you are human") ||
    t.includes("cf-chl") ||
    t.includes("cloudflare") ||
    t.includes("captcha") ||
    t.includes("access denied") ||
    t.includes("challenge-platform")
  );
}

/**
 * More robust: locate a year section by:
 * - id/name containing year (with optional suffix/prefix)
 * - href="#year..."
 * - header tags containing the year (h1..h4)
 *
 * Then cut the slice until the next year marker.
 */
function findSection(html, year) {
  const y = String(year);

  const markers = [
    // Anchors/ids/names
    new RegExp(`id=["'][^"']*${y}[^"']*["']`, "i"),
    new RegExp(`name=["'][^"']*${y}[^"']*["']`, "i"),
    new RegExp(`href=["']#${y}[^"']*["']`, "i"),

    // Common Top40Weekly variants
    new RegExp(`id=["']${y}-topsongslist["']`, "i"),
    new RegExp(`id=["']${y}[-_]?topsongslist["']`, "i"),
    new RegExp(`id=["']${y}[-_]?topsongs["']`, "i"),

    // Header containing the year
    new RegExp(`<h[1-4][^>]*>[^<]*\\b${y}\\b[^<]*<\\/h[1-4]>`, "i"),
  ];

  let start = -1;
  for (const rx of markers) {
    const m = rx.exec(html);
    if (m && typeof m.index === "number") {
      start = m.index;
      break;
    }
  }
  if (start < 0) return null;

  const nextYear = String(year + 1);
  const endMarkers = [
    new RegExp(`id=["'][^"']*${nextYear}[^"']*["']`, "i"),
    new RegExp(`name=["'][^"']*${nextYear}[^"']*["']`, "i"),
    new RegExp(`href=["']#${nextYear}[^"']*["']`, "i"),
    new RegExp(`<h[1-4][^>]*>[^<]*\\b${nextYear}\\b[^<]*<\\/h[1-4]>`, "i"),
  ];

  let end = html.length;
  const slice = html.slice(start);
  for (const rx of endMarkers) {
    const m = rx.exec(slice);
    if (m && typeof m.index === "number" && m.index > 10) {
      end = start + m.index;
      break;
    }
  }

  return html.slice(start, end);
}

/**
 * Extract candidate ranked “items” from HTML blocks first:
 * - <li>...</li>
 * - <tr>...</tr>
 * - <p>...</p>
 * Then parse each item for rank + "Artist – Title" / "Title – Artist".
 */
function extractRankItemsFromHtml(sectionHtml) {
  const html = String(sectionHtml || "");
  const blocks = [];

  const pushAll = (rx) => {
    let m;
    while ((m = rx.exec(html))) {
      const raw = m[1] || "";
      const t = decodeCommonEntities(stripTags(raw));
      if (t) blocks.push(t);
    }
  };

  // Prefer LI (most common for ranked lists)
  pushAll(/<li\b[^>]*>([\s\S]*?)<\/li>/gi);

  // Tables sometimes used
  pushAll(/<tr\b[^>]*>([\s\S]*?)<\/tr>/gi);

  // Sometimes paragraphs
  pushAll(/<p\b[^>]*>([\s\S]*?)<\/p>/gi);

  // If nothing, fallback to a coarse text slice
  if (blocks.length === 0) {
    const t = decodeCommonEntities(stripTags(html));
    if (t) blocks.push(t);
  }

  return blocks;
}

function parseOneRankLine(line) {
  const s = cleanText(line);
  if (!s) return null;

  // rank prefix: "1.", "1)", "1 -", "#1"
  const m =
    s.match(/^(?:#\s*)?(\d{1,3})\s*[.)-]?\s+(.*)$/) ||
    s.match(/^rank\s*(\d{1,3})\s*[:\-]\s*(.*)$/i);

  if (!m) return null;

  const rank = Number(m[1]);
  if (!Number.isFinite(rank) || rank < 1 || rank > 100) return null;

  const rest = cleanText(m[2]);
  if (!rest) return null;

  // Split on dash variants: "Artist – Title"
  const parts = rest.split(/\s+[-–—:]\s+/).map(cleanText).filter(Boolean);
  if (parts.length < 2) return null;

  const a = parts[0];
  const b = parts[1];

  const looksArtist = (x) =>
    /\b(feat\.|featuring|&|with)\b/i.test(x) ||
    /\b(orchestra|band|singers|quartet|trio)\b/i.test(x);

  let artist = "";
  let title = "";

  // Decide direction
  if (looksArtist(a) && !looksArtist(b)) {
    artist = a; title = b;
  } else if (!looksArtist(a) && looksArtist(b)) {
    title = a; artist = b;
  } else {
    // Default: Artist – Title
    artist = a; title = b;
  }

  artist = cleanText(artist.replace(/^["']|["']$/g, ""));
  title = cleanText(title.replace(/^["']|["']$/g, ""));

  if (!artist || !title) return null;

  return { rank, artist, title };
}

/**
 * For blocks that contain multiple ranks in one string,
 * extract repeated patterns without relying on line breaks.
 *
 * Example: "1. Artist – Song 2. Artist – Song 3. ..."
 */
function extractMultipleRankLines(blockText) {
  const t = " " + cleanText(blockText) + " ";
  if (!t.trim()) return [];

  const out = [];

  // Capture " (rank). .... " until next rank or end
  const rx = /(?:^|\s)(#?\s*\d{1,3})\s*[.)-]\s+([\s\S]*?)(?=(?:\s#?\s*\d{1,3}\s*[.)-]\s)|$)/g;

  let m;
  while ((m = rx.exec(t))) {
    const maybeRank = cleanText(m[1]).replace(/^#\s*/, "");
    const rank = Number(maybeRank);
    if (!Number.isFinite(rank) || rank < 1 || rank > 100) continue;

    const body = cleanText(m[2]);
    if (!body) continue;

    const parsed = parseOneRankLine(`${rank}. ${body}`);
    if (parsed) out.push(parsed);
  }

  return out;
}

function parseYearSection(sectionHtml, year) {
  const items = extractRankItemsFromHtml(sectionHtml);

  const rows = [];
  for (const item of items) {
    // First try single-line parse
    const one = parseOneRankLine(item);
    if (one) {
      rows.push({ year, rank: one.rank, artist: one.artist, title: one.title, source: SOURCE });
      continue;
    }

    // Then try multi-rank extraction
    const many = extractMultipleRankLines(item);
    for (const p of many) {
      rows.push({ year, rank: p.rank, artist: p.artist, title: p.title, source: SOURCE });
    }
  }

  // Deduplicate by rank (keep first)
  const seen = new Set();
  const uniq = [];
  for (const r of rows) {
    const k = `${r.year}:${r.rank}`;
    if (seen.has(k)) continue;
    seen.add(k);
    uniq.push(r);
  }

  uniq.sort((a, b) => a.rank - b.rank);
  return uniq;
}

function main() {
  if (!fs.existsSync(IN_FILE)) {
    console.error("Missing input file:", IN_FILE);
    console.error("Download it first to Data/raw/top40weekly/top-100-songs-of-the-60s.html");
    process.exit(1);
  }

  const html = fs.readFileSync(IN_FILE, "utf8");

  if (looksLikeBotBlock(html)) {
    console.error("Downloaded HTML looks like a bot/challenge page (Cloudflare/captcha).");
    console.error("Re-download with curl headers (User-Agent + --compressed), then re-run this script.");
    process.exit(2);
  }

  const allRows = [];
  for (let year = 1960; year <= 1969; year++) {
    const sectionHtml = findSection(html, year);
    if (!sectionHtml) {
      console.log(`Year ${year}: parsed 0 ranked rows (section not found)`);
      continue;
    }

    const rows = parseYearSection(sectionHtml, year);

    console.log(`Year ${year}: parsed ${rows.length} ranked rows`);
    allRows.push(...rows);
  }

  fs.writeFileSync(OUT_FILE, JSON.stringify(allRows, null, 2), "utf8");
  console.log("\nWrote:", OUT_FILE);
  console.log("Rows:", allRows.length);

  if (allRows.length === 0)S
  {
    console.log("\nDEBUG TIP: confirm anchors/headers exist in the HTML:");
    console.log('  Select-String -Path ".\\Data\\raw\\top40weekly\\top-100-songs-of-the-60s.html" -Pattern "1960","1960-","topsongs","topsongslist","<h2","<h3" -SimpleMatch | Select-Object -First 60');
  }
}

main();
