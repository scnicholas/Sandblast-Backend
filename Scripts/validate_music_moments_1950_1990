// Scripts/validate_story_moments_1950_1990.js
"use strict";

const fs = require("fs");
const path = require("path");

const FILE =
  process.argv[2] || path.resolve(process.cwd(), "Data/music_moments_v1.json");

const START = 1950;
const END = 1990;

// Hard spec + warning band
const HARD_MIN = 45;
const HARD_MAX = 65;
const TARGET_MIN = 50;
const TARGET_MAX = 60;

// Avoid filler that makes prose “roomy”
const FILLER = [
  "interestingly",
  "notably",
  "remarkably",
  "it’s worth",
  "it's worth",
  "in fact",
  "actually",
  "basically",
  "kind of",
  "sort of",
];

function cleanSpaces(s) {
  return String(s || "").replace(/\s+/g, " ").trim();
}

function wordCount(s) {
  const t = cleanSpaces(s);
  if (!t) return 0;
  return t.split(" ").filter(Boolean).length;
}

// Strip JS-style comments so JSON.parse works
function stripJsonComments(input) {
  let s = String(input || "");

  // remove /* ... */ blocks
  s = s.replace(/\/\*[\s\S]*?\*\//g, "");

  // remove //... line comments
  s = s.replace(/^\s*\/\/.*$/gm, "");

  return s;
}

function loadLenientJson(p) {
  const raw = fs.readFileSync(p, "utf8");
  const cleaned = stripJsonComments(raw);
  return JSON.parse(cleaned);
}

function hasDashAnchor(entry) {
  // You store anchor fields separately (artist/title/position),
  // but we still want to catch missing core fields.
  const artist = cleanSpaces(entry.artist);
  const title = cleanSpaces(entry.title);
  return Boolean(artist && title);
}

function hasTruthSpine(entry) {
  const yearOk =
    Number.isFinite(entry.year) && entry.year >= START && entry.year <= END;
  const rankOk = Number(entry.position) === 1 || Number(entry.rank) === 1 || true; // optional
  const chartOk = Boolean(cleanSpaces(entry.chart));
  return yearOk && hasDashAnchor(entry) && chartOk && rankOk;
}

function containsBrokenEncoding(text) {
  // These often show up when UTF-8 is mis-decoded as CP1252.
  // Examples you already have: â€” â€œ â€
  return /â€”|â€œ|â€|â€™|Â/.test(String(text || ""));
}

function includesInsensitive(hay, needle) {
  return String(hay || "").toLowerCase().includes(String(needle).toLowerCase());
}

function endsWithForwardBeat(text) {
  // We want story moments to end with a forward-driving beat.
  // If your format doesn’t include this yet, we’ll mark as WARN (not fail).
  const t = cleanSpaces(text).toLowerCase();
  if (!t) return false;
  return (
    t.endsWith("?") ||
    t.includes("want the top 10") ||
    t.includes("want the top ten") ||
    t.includes("want a micro") ||
    t.includes("next year") ||
    t.includes("another year")
  );
}

function main() {
  const db = loadLenientJson(FILE);

  if (!db || !Array.isArray(db.moments)) {
    console.error("FAIL: Expected { moments: [] } in", FILE);
    process.exit(2);
  }

  const story = db.moments.filter(
    (m) =>
      m &&
      String(m.type || "").toLowerCase() === "story_moment" &&
      Number(m.year) >= START &&
      Number(m.year) <= END
  );

  const byYear = new Map();
  for (const m of story) {
    const y = Number(m.year);
    if (!byYear.has(y)) byYear.set(y, []);
    byYear.get(y).push(m);
  }

  const missingYears = [];
  for (let y = START; y <= END; y++) {
    if (!byYear.has(y)) missingYears.push(y);
  }

  const hardIssues = [];
  const warnings = [];

  for (let y = START; y <= END; y++) {
    const entries = byYear.get(y) || [];

    // Expect exactly 1 story moment per year (warn if 0, hard if >1)
    if (entries.length > 1) {
      hardIssues.push({ year: y, type: "MULTIPLE_STORY_MOMENTS", count: entries.length });
    }

    for (const e of entries) {
      const text = cleanSpaces(e.moment_text);

      if (!text) {
        hardIssues.push({ year: y, type: "EMPTY_MOMENT_TEXT", id: e.id });
        continue;
      }

      if (/\bundefined\b|\bnull\b/i.test(text)) {
        hardIssues.push({ year: y, type: "JUNK_TOKEN_IN_TEXT", id: e.id });
      }

      // Truth spine fields present
      if (!hasTruthSpine(e)) {
        hardIssues.push({
          year: y,
          type: "MISSING_TRUTH_SPINE_FIELDS",
          id: e.id,
          artist: e.artist,
          title: e.title,
          chart: e.chart,
        });
      }

      // Word count validation
      const wc = wordCount(text);
      if (wc < HARD_MIN || wc > HARD_MAX) {
        hardIssues.push({ year: y, type: "WORDCOUNT_FAIL", words: wc, id: e.id });
      } else if (wc < TARGET_MIN || wc > TARGET_MAX) {
        warnings.push({ year: y, type: "WORDCOUNT_WARN", words: wc, id: e.id });
      }

      // Encoding artifacts (warn; but should be fixed before public)
      if (containsBrokenEncoding(text)) {
        warnings.push({ year: y, type: "BROKEN_ENCODING", id: e.id });
      }

      // Filler terms (warn)
      for (const f of FILLER) {
        if (includesInsensitive(text, f)) {
          warnings.push({ year: y, type: "FILLER_TERM", term: f, id: e.id });
        }
      }

      // Forward-driving ending beat (warn for now)
      if (!endsWithForwardBeat(text)) {
        warnings.push({ year: y, type: "NO_FORWARD_BEAT_ENDING", id: e.id });
      }
    }
  }

  console.log("=== STORY MOMENTS VALIDATION: 1950–1990 ===");
  console.log("File:", FILE);
  console.log("Story moments found:", story.length);
  console.log("Missing years:", missingYears.length ? missingYears.join(", ") : "none");
  console.log("Hard issues:", hardIssues.length);
  console.log("Warnings:", warnings.length);

  if (missingYears.length) {
    console.log("\n[MISSING YEARS]");
    console.log(missingYears.join(", "));
  }

  if (hardIssues.length) {
    console.log("\n[HARD ISSUES] (first 200)");
    hardIssues.slice(0, 200).forEach((x) => console.log(x));
    if (hardIssues.length > 200) console.log("...truncated");
  }

  if (warnings.length) {
    console.log("\n[WARNINGS] (first 200)");
    warnings.slice(0, 200).forEach((x) => console.log(x));
    if (warnings.length > 200) console.log("...truncated");
  }

  // Exit code: fail if missing years or hard issues
  const fail = missingYears.length > 0 || hardIssues.length > 0;
  process.exit(fail ? 1 : 0);
}

main();
