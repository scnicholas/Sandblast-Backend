/**
 * Dump Top40Weekly "Top 100 Songs Of YEAR" pages into CSV: year,artist,title
 *
 * Recommended (writes UTF-8 file directly; avoids PowerShell piping issues):
 *   node scripts/top40weekly_top100_dump.js 1980 1980 Data\top40weekly_top100_1980.csv
 *
 * Or stdout:
 *   node scripts/top40weekly_top100_dump.js 1960 2019
 */

"use strict";

const fs = require("fs");
const path = require("path");
const cheerio = require("cheerio");

const startYear = parseInt(process.argv[2], 10);
const endYear = parseInt(process.argv[3], 10);
const outPath = process.argv[4]; // optional

if (!startYear || !endYear || endYear < startYear) {
  console.error("Usage: node scripts/top40weekly_top100_dump.js <startYear> <endYear> [out.csv]");
  process.exit(1);
}

function normLine(s) {
  return String(s || "")
    .replace(/\u00A0/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

async function fetchHtml(url) {
  const res = await fetch(url, { headers: { "User-Agent": "Mozilla/5.0" } });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.text();
}

/**
 * DOM-ordered parser:
 * - Reads text nodes in .entry-content in document order
 * - Pairs: "N Title" then next meaningful line "Artist"
 * - Does not rely on newline behavior of .text()
 */
function extractTop100FromPage($) {
  const entry = $(".entry-content").first();
  if (!entry.length) return [];

  const chunks = [];

  // Walk text nodes inside entry content in reading order
  entry.find("*").contents().each((_, node) => {
    if (node.type === "text") {
      const t = normLine(node.data);
      if (t) chunks.push(t);
    }
  });

  // Also include direct text under entry itself
  entry.contents().each((_, node) => {
    if (node.type === "text") {
      const t = normLine(node.data);
      if (t) chunks.push(t);
    }
  });

  const clean = chunks
    .map(normLine)
    .filter(Boolean)
    .filter(s => s.length < 220)
    .filter(s => !/^share|^posted|^leave a reply/i.test(s));

  const out = [];

  for (let i = 0; i < clean.length - 1; i++) {
    const m = clean[i].match(/^(\d{1,3})\s+(.+)$/);
    if (!m) continue;

    const rank = parseInt(m[1], 10);
    const title = normLine(m[2]);
    if (!rank || !title) continue;

    let artist = "";
    for (let j = i + 1; j < clean.length; j++) {
      const cand = normLine(clean[j]);
      if (!cand) continue;

      // if we hit another rank/title line before artist, bail
      if (/^\d{1,3}\s+/.test(cand)) {
        artist = "";
        break;
      }

      const lc = cand.toLowerCase();
      if (lc.includes("top songs of")) continue;
      if (lc.startsWith("these are the top")) continue;
      if (lc.startsWith("there are")) continue;

      artist = cand;
      i = j; // advance outer loop past artist
      break;
    }

    if (!artist) continue;

    if (title.length > 180 || artist.length > 140) continue;

    out.push({ rank, title, artist });
  }

  // De-dupe by rank
  const byRank = new Map();
  for (const r of out) if (!byRank.has(r.rank)) byRank.set(r.rank, r);

  return Array.from(byRank.values()).sort((a, b) => a.rank - b.rank);
}

(async () => {
  const csvLines = [];
  csvLines.push("year,artist,title");

  for (let y = startYear; y <= endYear; y++) {
    const url = `https://top40weekly.com/top-100-songs-of-${y}/`;

    try {
      const html = await fetchHtml(url);
      const $ = cheerio.load(html);

      const rows = extractTop100FromPage($);

      // quick proof for the exact year we care about
      if (y === 1980) {
        console.error(`[DEBUG] 1980 rows=${rows.length} sample=${JSON.stringify(rows.slice(0, 5))}`);
      }

      if (rows.length < 50) {
        console.error(`[WARN] ${y}: parsed only ${rows.length} rows (${url})`);
        continue;
      }

      console.error(`[OK] ${y}: ${rows.length} rows (${url})`);

      for (const r of rows) {
        const a = `"${String(r.artist).replace(/"/g, '""')}"`;
        const t = `"${String(r.title).replace(/"/g, '""')}"`;
        csvLines.push(`${y},${a},${t}`);
      }
    } catch (e) {
      console.error(`[WARN] ${y}: ${e.message} (${url})`);
    }
  }

  const csv = csvLines.join("\n") + "\n";

  if (outPath) {
    const full = path.resolve(process.cwd(), outPath);
    fs.mkdirSync(path.dirname(full), { recursive: true });
    fs.writeFileSync(full, csv, "utf8");
    console.error(`[DONE] wrote ${csvLines.length - 1} rows to ${full}`);
  } else {
    process.stdout.write(csv);
  }
})();
