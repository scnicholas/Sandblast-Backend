"use strict";

/**
 * Scripts/build_top10_by_year_from_wiki_cache_1950_2025.js
 *
 * Build Top10 store from Wikipedia per-year cache:
 *   Data/wikipedia/charts/year_end_hot100_<YEAR>.json
 *
 * Output:
 *   Data/top10_by_year_v1.json
 *
 * Baseline: Top 10 = first 10 VALID song rows from each year cache.
 * Canonical rule: pos is ALWAYS 1–10 by order (index-based) AFTER cleaning/filtering.
 * Optional overlay: if Data/top10_input_rows.json contains rows for a year,
 * it can overwrite those entries (higher authority).
 *
 * Usage:
 *   node Scripts/build_top10_by_year_from_wiki_cache_1950_2025.js
 */

const fs = require("fs");
const path = require("path");

const YEAR_START = 1950;
const YEAR_END = 2025;

const DATA_DIR = path.resolve(__dirname, "..", "Data");
const WIKI_DIR = path.join(DATA_DIR, "wikipedia", "charts");
const OUT_FILE = path.join(DATA_DIR, "top10_by_year_v1.json");

const TOP10_INPUT_ROWS = path.join(DATA_DIR, "top10_input_rows.json"); // optional overlay

const CHART_NAME = "Billboard Year-End Hot 100 (Wikipedia cache)";

function readJson(fp) {
  return JSON.parse(fs.readFileSync(fp, "utf8"));
}
function writeJson(fp, obj) {
  fs.writeFileSync(fp, JSON.stringify(obj, null, 2), "utf8");
}

function isNonEmptyString(x) {
  return typeof x === "string" && x.trim().length > 0;
}

function normStr(x) {
  return String(x || "")
    .replace(/\u00a0/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function stripWrappingQuotes(s) {
  let x = normStr(s);
  // Remove outer quotes repeatedly ("..."), (‘...’), (“...”)
  for (let i = 0; i < 3; i++) {
    const m = x.match(/^["'“”‘’](.*)["'“”‘’]$/);
    if (!m) break;
    x = normStr(m[1]);
  }
  return x;
}

function stripCitations(s) {
  // Remove common wiki footnote markers like [1], [a], [12]
  return normStr(String(s || "").replace(/\[[^\]]*?\]/g, ""));
}

function toInt(x) {
  const n = parseInt(String(x || "").replace(/[^\d]/g, ""), 10);
  return Number.isFinite(n) ? n : null;
}

function getField(row, keys) {
  if (!row || typeof row !== "object") return "";
  for (const k of keys) {
    if (row[k] != null) return row[k];
  }
  return "";
}

function normalizeTitleArtist(rawTitle, rawArtist) {
  let title = stripWrappingQuotes(stripCitations(rawTitle));
  let artist = stripWrappingQuotes(stripCitations(rawArtist));

  // Final normalize
  title = normStr(title);
  artist = normStr(artist);

  return { title, artist };
}

function isHeaderLikeToken(x) {
  const t = normStr(x).toLowerCase();
  return (
    t === "title" ||
    t === "song" ||
    t === "single" ||
    t === "track" ||
    t === "artist" ||
    t === "artist(s)" ||
    t === "artists" ||
    t === "performer" ||
    t === "№" ||
    t === "no" ||
    t === "no." ||
    t === "rank" ||
    t === "pos" ||
    t === "position"
  );
}

function isHeaderRow(title, artist) {
  const t = normStr(title).toLowerCase();
  const a = normStr(artist).toLowerCase();
  if (!t && !a) return true;

  // Exact header pairs
  if (isHeaderLikeToken(t) && isHeaderLikeToken(a)) return true;

  // Common “Title / Artist(s)” pattern
  const tIsTitle = t === "title" || t === "song" || t === "single" || t === "track";
  const aIsArtist = a === "artist" || a === "artist(s)" || a === "artists" || a === "performer";
  if (tIsTitle && (aIsArtist || !a)) return true;
  if (aIsArtist && (!t || tIsTitle)) return true;

  return false;
}

function isJunkRow(title, artist) {
  const t = normStr(title);
  const a = normStr(artist);
  if (!t && !a) return true;
  if (isHeaderRow(t, a)) return true;

  // Kill obvious corrupted rows where artist == title (you have these in output)
  // e.g. title="Play a Simple Melody", artist="Play a Simple Melody"
  if (t && a && t.toLowerCase() === a.toLowerCase()) return true;

  // Too-short junk that’s not plausible content
  if (t.length < 2 || a.length < 2) return true;

  return false;
}

function loadWikiYear(year) {
  const fp = path.join(WIKI_DIR, `year_end_hot100_${year}.json`);
  if (!fs.existsSync(fp)) return null;

  let j;
  try {
    j = readJson(fp);
  } catch {
    return [];
  }
  return Array.isArray(j.rows) ? j.rows : [];
}

function buildTop10FromRows(rows) {
  if (!Array.isArray(rows) || rows.length < 10) return null;

  // Extract, clean, filter; then SCAN until we collect 10 good unique rows.
  const picked = [];
  const seen = new Set();

  for (const r of rows) {
    // Be tolerant to different key casings from caches
    const rawTitle = getField(r, ["title", "Title", "song", "Song", "single", "Single", "track", "Track"]);
    const rawArtist = getField(r, [
      "artist",
      "Artist",
      "artist(s)",
      "Artist(s)",
      "artists",
      "Artists",
      "performer",
      "Performer"
    ]);

    const { title, artist } = normalizeTitleArtist(rawTitle, rawArtist);

    // Preserve original position if present (provenance only)
    const sourcePos = toInt(getField(r, ["pos", "Pos", "position", "Position", "rank", "Rank", "№", "No.", "no"]));

    if (!isNonEmptyString(title) || !isNonEmptyString(artist)) continue;
    if (isJunkRow(title, artist)) continue;

    // Deduplicate by canonical key
    const key = `${title.toLowerCase()}@@${artist.toLowerCase()}`;
    if (seen.has(key)) continue;
    seen.add(key);

    picked.push({
      title,
      artist,
      ...(sourcePos ? { sourcePos } : {})
    });

    if (picked.length >= 10) break;
  }

  if (picked.length < 10) return null;

  // Canonical Top10: ordering defines rank (after cleaning)
  const top10 = picked.slice(0, 10).map((r, idx) => ({
    pos: idx + 1,
    title: r.title,
    artist: r.artist,
    ...(r.sourcePos ? { sourcePos: r.sourcePos } : {})
  }));

  // Validate hard
  for (let i = 0; i < 10; i++) {
    const it = top10[i];
    if (it.pos !== i + 1) return null;
    if (!isNonEmptyString(it.title)) return null;
    if (!isNonEmptyString(it.artist)) return null;
    if (isHeaderRow(it.title, it.artist)) return null;
    if (it.title.toLowerCase() === it.artist.toLowerCase()) return null;
  }

  return top10;
}

function buildOverlayMapFromInputRows() {
  if (!fs.existsSync(TOP10_INPUT_ROWS)) return new Map();

  let j;
  try {
    j = readJson(TOP10_INPUT_ROWS);
  } catch {
    return new Map();
  }

  const rows = Array.isArray(j) ? j : Array.isArray(j.rows) ? j.rows : [];
  const byYear = new Map();

  for (const r of rows) {
    const y = toInt(r.year);
    const pos = toInt(r.pos ?? r.position ?? r.rank);
    const rawTitle = r.title ?? r.song ?? r.single ?? r.track ?? r.Title ?? r.Song;
    const rawArtist = r.artist ?? r["artist(s)"] ?? r["Artist(s)"] ?? r.artists ?? r.performer ?? r.Artist;

    const { title, artist } = normalizeTitleArtist(rawTitle, rawArtist);

    if (!y || !pos || !isNonEmptyString(title) || !isNonEmptyString(artist)) continue;
    if (isHeaderRow(title, artist)) continue;
    if (title.toLowerCase() === artist.toLowerCase()) continue;

    if (!byYear.has(y)) byYear.set(y, []);
    byYear.get(y).push({ pos, title, artist });
  }

  const out = new Map();
  for (const [y, items] of byYear.entries()) {
    const sorted = items
      .filter((it) => it.pos >= 1 && it.pos <= 10)
      .sort((a, b) => a.pos - b.pos);

    if (sorted.length >= 10) {
      out.set(
        y,
        sorted.slice(0, 10).map((it, idx) => ({
          pos: idx + 1,
          title: it.title,
          artist: it.artist,
          sourcePos: it.pos
        }))
      );
    }
  }
  return out;
}

function main() {
  if (!fs.existsSync(WIKI_DIR)) {
    console.error(`❌ Missing wiki cache dir: ${WIKI_DIR}`);
    process.exitCode = 1;
    return;
  }

  const overlay = buildOverlayMapFromInputRows();
  const years = {};
  const missing = [];
  const weak = [];

  for (let y = YEAR_START; y <= YEAR_END; y++) {
    // Always create a key, even if missing/weak (keeps 1950–2025 continuous)
    const yKey = String(y);

    if (overlay.has(y)) {
      years[yKey] = { year: y, chart: CHART_NAME, items: overlay.get(y) };
      continue;
    }

    const rows = loadWikiYear(y);
    if (rows === null) {
      missing.push(y);
      years[yKey] = { year: y, chart: CHART_NAME, items: [] };
      continue;
    }

    const top10 = buildTop10FromRows(rows);
    if (!top10) {
      weak.push(y);
      years[yKey] = { year: y, chart: CHART_NAME, items: [] };
      continue;
    }

    years[yKey] = { year: y, chart: CHART_NAME, items: top10 };
  }

  const payload = {
    version: "top10_by_year_v1",
    chart: "Billboard Year-End Hot 100",
    source: "Wikipedia per-year cache (Data/wikipedia/charts) + optional overlay",
    generatedAt: new Date().toISOString(),
    meta: {
      yearStart: YEAR_START,
      yearEnd: YEAR_END,
      wikiDir: path.relative(process.cwd(), WIKI_DIR),
      overlayUsedYears: Array.from(overlay.keys()).sort((a, b) => a - b),
      missingYears: missing,
      weakYears: weak
    },
    years
  };

  writeJson(OUT_FILE, payload);

  console.log("✅ Wrote:", path.relative(process.cwd(), OUT_FILE));
  console.log("Years:", Object.keys(years).length, "Missing:", missing.length, "Weak:", weak.length);
  if (missing.length) console.log("Missing:", missing.join(", "));
  if (weak.length) console.log("Weak:", weak.join(", "));
}

main();
